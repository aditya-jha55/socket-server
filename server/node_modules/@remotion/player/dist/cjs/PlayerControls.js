"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Controls = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const remotion_1 = require("remotion");
const format_time_js_1 = require("./format-time.js");
const icons_js_1 = require("./icons.js");
const MediaVolumeSlider_js_1 = require("./MediaVolumeSlider.js");
const PlayerSeekBar_js_1 = require("./PlayerSeekBar.js");
const use_video_controls_resize_js_1 = require("./use-video-controls-resize.js");
const gradientSteps = [
    0, 0.013, 0.049, 0.104, 0.175, 0.259, 0.352, 0.45, 0.55, 0.648, 0.741, 0.825,
    0.896, 0.951, 0.987,
];
const gradientOpacities = [
    0, 8.1, 15.5, 22.5, 29, 35.3, 41.2, 47.1, 52.9, 58.8, 64.7, 71, 77.5, 84.5,
    91.9,
];
const globalGradientOpacity = 1 / 0.7;
const containerStyle = {
    boxSizing: 'border-box',
    position: 'absolute',
    bottom: 0,
    width: '100%',
    paddingTop: 40,
    paddingBottom: 10,
    backgroundImage: `linear-gradient(to bottom,${gradientSteps
        .map((g, i) => {
        return `hsla(0, 0%, 0%, ${g}) ${gradientOpacities[i] * globalGradientOpacity}%`;
    })
        .join(', ')}, hsl(0, 0%, 0%) 100%)`,
    backgroundSize: 'auto 145px',
    display: 'flex',
    paddingRight: use_video_controls_resize_js_1.X_PADDING,
    paddingLeft: use_video_controls_resize_js_1.X_PADDING,
    flexDirection: 'column',
    transition: 'opacity 0.3s',
};
const buttonStyle = {
    appearance: 'none',
    backgroundColor: 'transparent',
    border: 'none',
    cursor: 'pointer',
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 6,
    paddingBottom: 6,
    height: 37,
    display: 'inline',
    marginBottom: 0,
    marginTop: 0,
};
const controlsRow = {
    display: 'flex',
    flexDirection: 'row',
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
    userSelect: 'none',
};
const leftPartStyle = {
    display: 'flex',
    flexDirection: 'row',
    userSelect: 'none',
    alignItems: 'center',
};
const xSpacer = {
    width: 10,
};
const ySpacer = {
    height: 8,
};
const flex1 = {
    flex: 1,
};
const fullscreen = {};
const PlayPauseButton = ({ playing }) => playing ? (0, jsx_runtime_1.jsx)(icons_js_1.PauseIcon, {}) : (0, jsx_runtime_1.jsx)(icons_js_1.PlayIcon, {});
const Controls = ({ durationInFrames, hovered, isFullscreen, fps, player, showVolumeControls, onFullscreenButtonClick, allowFullscreen, onExitFullscreenButtonClick, spaceKeyToPlayOrPause, onSeekEnd, onSeekStart, inFrame, outFrame, initiallyShowControls, playerWidth, renderPlayPauseButton, renderFullscreenButton, alwaysShowControls, }) => {
    const playButtonRef = (0, react_1.useRef)(null);
    const frame = remotion_1.Internals.Timeline.useTimelinePosition();
    const [supportsFullscreen, setSupportsFullscreen] = (0, react_1.useState)(false);
    const { maxTimeLabelWidth, displayVerticalVolumeSlider } = (0, use_video_controls_resize_js_1.useVideoControlsResize)({ allowFullscreen, playerWidth });
    const [shouldShowInitially, setInitiallyShowControls] = (0, react_1.useState)(() => {
        if (typeof initiallyShowControls === 'boolean') {
            return initiallyShowControls;
        }
        if (typeof initiallyShowControls === 'number') {
            if (initiallyShowControls % 1 !== 0) {
                throw new Error('initiallyShowControls must be an integer or a boolean');
            }
            if (Number.isNaN(initiallyShowControls)) {
                throw new Error('initiallyShowControls must not be NaN');
            }
            if (!Number.isFinite(initiallyShowControls)) {
                throw new Error('initiallyShowControls must be finite');
            }
            if (initiallyShowControls <= 0) {
                throw new Error('initiallyShowControls must be a positive integer');
            }
            return initiallyShowControls;
        }
        throw new TypeError('initiallyShowControls must be a number or a boolean');
    });
    const containerCss = (0, react_1.useMemo)(() => {
        // Hide if playing and mouse outside
        const shouldShow = hovered || !player.playing || shouldShowInitially || alwaysShowControls;
        return {
            ...containerStyle,
            opacity: Number(shouldShow),
        };
    }, [hovered, shouldShowInitially, player.playing, alwaysShowControls]);
    (0, react_1.useEffect)(() => {
        if (playButtonRef.current && spaceKeyToPlayOrPause) {
            // This switches focus to play button when player.playing flag changes
            playButtonRef.current.focus({
                preventScroll: true,
            });
        }
    }, [player.playing, spaceKeyToPlayOrPause]);
    (0, react_1.useEffect)(() => {
        var _a;
        // Must be handled client-side to avoid SSR hydration mismatch
        setSupportsFullscreen((_a = (typeof document !== 'undefined' &&
            (document.fullscreenEnabled || document.webkitFullscreenEnabled))) !== null && _a !== void 0 ? _a : false);
    }, []);
    (0, react_1.useEffect)(() => {
        if (shouldShowInitially === false) {
            return;
        }
        const time = shouldShowInitially === true ? 2000 : shouldShowInitially;
        const timeout = setTimeout(() => {
            setInitiallyShowControls(false);
        }, time);
        return () => {
            clearInterval(timeout);
        };
    }, [shouldShowInitially]);
    const timeLabel = (0, react_1.useMemo)(() => {
        return {
            color: 'white',
            fontFamily: 'sans-serif',
            fontSize: 14,
            maxWidth: maxTimeLabelWidth === null ? undefined : maxTimeLabelWidth,
            overflow: 'hidden',
            textOverflow: 'ellipsis',
        };
    }, [maxTimeLabelWidth]);
    return ((0, jsx_runtime_1.jsxs)("div", { style: containerCss, children: [(0, jsx_runtime_1.jsxs)("div", { style: controlsRow, children: [(0, jsx_runtime_1.jsxs)("div", { style: leftPartStyle, children: [(0, jsx_runtime_1.jsx)("button", { ref: playButtonRef, type: "button", style: buttonStyle, onClick: player.playing ? player.pause : player.play, "aria-label": player.playing ? 'Pause video' : 'Play video', title: player.playing ? 'Pause video' : 'Play video', children: renderPlayPauseButton === null ? ((0, jsx_runtime_1.jsx)(PlayPauseButton, { playing: player.playing })) : (renderPlayPauseButton({ playing: player.playing })) }), showVolumeControls ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("div", { style: xSpacer }), (0, jsx_runtime_1.jsx)(MediaVolumeSlider_js_1.MediaVolumeSlider, { displayVerticalVolumeSlider: displayVerticalVolumeSlider })] })) : null, (0, jsx_runtime_1.jsx)("div", { style: xSpacer }), (0, jsx_runtime_1.jsxs)("div", { style: timeLabel, children: [(0, format_time_js_1.formatTime)(frame / fps), " / ", (0, format_time_js_1.formatTime)(durationInFrames / fps)] }), (0, jsx_runtime_1.jsx)("div", { style: xSpacer })] }), (0, jsx_runtime_1.jsx)("div", { style: flex1 }), (0, jsx_runtime_1.jsx)("div", { style: fullscreen, children: supportsFullscreen && allowFullscreen ? ((0, jsx_runtime_1.jsx)("button", { type: "button", "aria-label": isFullscreen ? 'Exit fullscreen' : 'Enter Fullscreen', title: isFullscreen ? 'Exit fullscreen' : 'Enter Fullscreen', style: buttonStyle, onClick: isFullscreen
                                ? onExitFullscreenButtonClick
                                : onFullscreenButtonClick, children: renderFullscreenButton === null ? ((0, jsx_runtime_1.jsx)(icons_js_1.FullscreenIcon, { isFullscreen: isFullscreen })) : (renderFullscreenButton({ isFullscreen })) })) : null })] }), (0, jsx_runtime_1.jsx)("div", { style: ySpacer }), (0, jsx_runtime_1.jsx)(PlayerSeekBar_js_1.PlayerSeekBar, { onSeekEnd: onSeekEnd, onSeekStart: onSeekStart, durationInFrames: durationInFrames, inFrame: inFrame, outFrame: outFrame })] }));
};
exports.Controls = Controls;
