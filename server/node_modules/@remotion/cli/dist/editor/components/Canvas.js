"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Canvas = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const player_1 = require("@remotion/player");
const react_1 = require("react");
const smooth_zoom_1 = require("../../smooth-zoom");
const colors_1 = require("../helpers/colors");
const get_effective_translation_1 = require("../helpers/get-effective-translation");
const is_current_selected_still_1 = require("../helpers/is-current-selected-still");
const use_keybinding_1 = require("../helpers/use-keybinding");
const editor_zoom_gestures_1 = require("../state/editor-zoom-gestures");
const preview_size_1 = require("../state/preview-size");
const layout_1 = require("./layout");
const Preview_1 = require("./Preview");
const ResetZoomButton_1 = require("./ResetZoomButton");
const container = {
    flex: 1,
    display: 'flex',
    overflow: 'hidden',
    position: 'relative',
    backgroundColor: colors_1.BACKGROUND,
};
const resetZoom = {
    position: 'absolute',
    top: layout_1.SPACING_UNIT * 2,
    right: layout_1.SPACING_UNIT * 2,
};
const ZOOM_PX_FACTOR = 0.003;
const Canvas = () => {
    const dimensions = (0, is_current_selected_still_1.useDimensions)();
    const ref = (0, react_1.useRef)(null);
    const { setSize, size: previewSize } = (0, react_1.useContext)(preview_size_1.PreviewSizeContext);
    const { editorZoomGestures } = (0, react_1.useContext)(editor_zoom_gestures_1.EditorZoomGesturesContext);
    const keybindings = (0, use_keybinding_1.useKeybinding)();
    const size = player_1.PlayerInternals.useElementSize(ref, {
        triggerOnWindowResize: false,
        shouldApplyCssTransforms: true,
    });
    const isFit = previewSize.size === 'auto' ||
        (previewSize.size === 1 &&
            previewSize.translation.x === 0 &&
            previewSize.translation.y === 0);
    const onWheel = (0, react_1.useCallback)((e) => {
        if (!editorZoomGestures) {
            return;
        }
        if (!size) {
            return;
        }
        if (!dimensions) {
            return;
        }
        const wantsToZoom = e.ctrlKey || e.metaKey;
        if (!wantsToZoom && isFit) {
            return;
        }
        e.preventDefault();
        setSize((prevSize) => {
            const scale = player_1.PlayerInternals.calculateScale({
                canvasSize: size,
                compositionHeight: dimensions.height,
                compositionWidth: dimensions.width,
                previewSize: prevSize.size,
            });
            // Zoom in/out
            if (wantsToZoom) {
                const oldSize = prevSize.size === 'auto' ? scale : prevSize.size;
                const smoothened = (0, smooth_zoom_1.smoothenZoom)(oldSize);
                const added = smoothened + e.deltaY * ZOOM_PX_FACTOR;
                const unsmoothened = (0, smooth_zoom_1.unsmoothenZoom)(added);
                const { centerX, centerY } = (0, get_effective_translation_1.getCenterPointWhileScrolling)({
                    size,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    compositionWidth: dimensions.width,
                    compositionHeight: dimensions.height,
                    scale,
                    translation: prevSize.translation,
                });
                const zoomDifference = unsmoothened - oldSize;
                const uvCoordinatesX = centerX / dimensions.width;
                const uvCoordinatesY = centerY / dimensions.height;
                const correctionLeft = -uvCoordinatesX * (zoomDifference * dimensions.width) +
                    (1 - uvCoordinatesX) * zoomDifference * dimensions.width;
                const correctionTop = -uvCoordinatesY * (zoomDifference * dimensions.height) +
                    (1 - uvCoordinatesY) * zoomDifference * dimensions.height;
                return {
                    translation: (0, get_effective_translation_1.getEffectiveTranslation)({
                        translation: {
                            x: prevSize.translation.x - correctionLeft / 2,
                            y: prevSize.translation.y - correctionTop / 2,
                        },
                        canvasSize: size,
                        compositionHeight: dimensions.height,
                        compositionWidth: dimensions.width,
                        scale,
                    }),
                    size: unsmoothened,
                };
            }
            const effectiveTranslation = (0, get_effective_translation_1.getEffectiveTranslation)({
                translation: prevSize.translation,
                canvasSize: size,
                compositionHeight: dimensions.height,
                compositionWidth: dimensions.width,
                scale,
            });
            // Pan
            return {
                ...prevSize,
                translation: (0, get_effective_translation_1.getEffectiveTranslation)({
                    translation: {
                        x: effectiveTranslation.x + e.deltaX,
                        y: effectiveTranslation.y + e.deltaY,
                    },
                    canvasSize: size,
                    compositionHeight: dimensions.height,
                    compositionWidth: dimensions.width,
                    scale,
                }),
            };
        });
    }, [editorZoomGestures, dimensions, isFit, setSize, size]);
    (0, react_1.useEffect)(() => {
        const { current } = ref;
        if (!current) {
            return;
        }
        current.addEventListener('wheel', onWheel, { passive: false });
        return () => 
        // @ts-expect-error
        current.removeEventListener('wheel', onWheel, {
            passive: false,
        });
    }, [onWheel]);
    const onReset = (0, react_1.useCallback)(() => {
        setSize(() => {
            return {
                translation: {
                    x: 0,
                    y: 0,
                },
                size: 'auto',
            };
        });
    }, [setSize]);
    const onZoomIn = (0, react_1.useCallback)(() => {
        if (!dimensions) {
            return;
        }
        if (!size) {
            return;
        }
        setSize((prevSize) => {
            const scale = player_1.PlayerInternals.calculateScale({
                canvasSize: size,
                compositionHeight: dimensions.height,
                compositionWidth: dimensions.width,
                previewSize: prevSize.size,
            });
            return {
                translation: {
                    x: 0,
                    y: 0,
                },
                size: Math.min(smooth_zoom_1.MAX_ZOOM, scale * 2),
            };
        });
    }, [dimensions, setSize, size]);
    const onZoomOut = (0, react_1.useCallback)(() => {
        if (!dimensions) {
            return;
        }
        if (!size) {
            return;
        }
        setSize((prevSize) => {
            const scale = player_1.PlayerInternals.calculateScale({
                canvasSize: size,
                compositionHeight: dimensions.height,
                compositionWidth: dimensions.width,
                previewSize: prevSize.size,
            });
            return {
                translation: {
                    x: 0,
                    y: 0,
                },
                size: Math.max(smooth_zoom_1.MIN_ZOOM, scale / 2),
            };
        });
    }, [dimensions, setSize, size]);
    (0, react_1.useEffect)(() => {
        const resetBinding = keybindings.registerKeybinding({
            event: 'keydown',
            key: '0',
            commandCtrlKey: false,
            callback: onReset,
            preventDefault: true,
        });
        const zoomIn = keybindings.registerKeybinding({
            event: 'keydown',
            key: '+',
            commandCtrlKey: false,
            callback: onZoomIn,
            preventDefault: true,
        });
        const zoomOut = keybindings.registerKeybinding({
            event: 'keydown',
            key: '-',
            commandCtrlKey: false,
            callback: onZoomOut,
            preventDefault: true,
        });
        return () => {
            resetBinding.unregister();
            zoomIn.unregister();
            zoomOut.unregister();
        };
    }, [keybindings, onReset, onZoomIn, onZoomOut]);
    return ((0, jsx_runtime_1.jsxs)("div", { ref: ref, style: container, children: [size ? (0, jsx_runtime_1.jsx)(Preview_1.VideoPreview, { canvasSize: size }) : null, isFit ? null : ((0, jsx_runtime_1.jsx)("div", { style: resetZoom, className: "css-reset", children: (0, jsx_runtime_1.jsx)(ResetZoomButton_1.ResetZoomButton, { onClick: onReset }) }))] }));
};
exports.Canvas = Canvas;
