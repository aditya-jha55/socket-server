"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimelineTimeIndicators = exports.TimelineTimePadding = exports.TimelineTimePlaceholders = exports.TIMELINE_TIME_INDICATOR_HEIGHT = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const player_1 = require("@remotion/player");
const react_1 = require("react");
const remotion_1 = require("remotion");
const colors_1 = require("../../helpers/colors");
const timeline_layout_1 = require("../../helpers/timeline-layout");
const render_frame_1 = require("../../state/render-frame");
const TimeValue_1 = require("../TimeValue");
const timeline_refs_1 = require("./timeline-refs");
const timeline_scroll_logic_1 = require("./timeline-scroll-logic");
const TimelineListItem_1 = require("./TimelineListItem");
exports.TIMELINE_TIME_INDICATOR_HEIGHT = 30;
const container = {
    height: exports.TIMELINE_TIME_INDICATOR_HEIGHT - 4,
    boxShadow: `0 0 4px ${colors_1.TIMELINE_BACKGROUND}`,
    position: 'absolute',
    backgroundColor: colors_1.TIMELINE_BACKGROUND,
    top: 0,
    left: 0,
};
const tick = {
    width: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    height: 20,
    position: 'absolute',
};
const secondTick = {
    ...tick,
    height: 15,
};
const tickLabel = {
    fontSize: 12,
    marginLeft: 8,
    marginTop: 7,
    color: colors_1.LIGHT_TEXT,
};
const timeValue = {
    height: exports.TIMELINE_TIME_INDICATOR_HEIGHT,
    position: 'absolute',
    top: 0,
    width: '100%',
    paddingLeft: TimelineListItem_1.TOTAL_TIMELINE_LAYER_LEFT_PADDING,
    boxShadow: `0 0 20px ${colors_1.BACKGROUND}`,
    display: 'flex',
    alignItems: 'center',
    background: colors_1.BACKGROUND,
};
const TimelineTimePlaceholders = () => {
    const ref = (0, react_1.useRef)(null);
    (0, react_1.useEffect)(() => {
        const currentRef = ref.current;
        if (!currentRef) {
            return;
        }
        const { current } = timeline_refs_1.timelineVerticalScroll;
        if (!current) {
            return;
        }
        const onScroll = () => {
            currentRef.style.top = current.scrollTop + 'px';
        };
        current.addEventListener('scroll', onScroll);
        return () => {
            current.removeEventListener('scroll', onScroll);
        };
    }, []);
    return ((0, jsx_runtime_1.jsx)("div", { ref: ref, style: timeValue, children: (0, jsx_runtime_1.jsx)(TimeValue_1.TimeValue, {}) }));
};
exports.TimelineTimePlaceholders = TimelineTimePlaceholders;
const TimelineTimePadding = () => {
    return ((0, jsx_runtime_1.jsx)("div", { style: {
            height: exports.TIMELINE_TIME_INDICATOR_HEIGHT,
        } }));
};
exports.TimelineTimePadding = TimelineTimePadding;
const TimelineTimeIndicators = () => {
    var _a;
    const size = player_1.PlayerInternals.useElementSize(timeline_refs_1.sliderAreaRef, {
        triggerOnWindowResize: false,
        shouldApplyCssTransforms: true,
    });
    const video = remotion_1.Internals.useVideo();
    const windowWidth = (_a = size === null || size === void 0 ? void 0 : size.width) !== null && _a !== void 0 ? _a : 0;
    const ref = (0, react_1.useRef)(null);
    (0, react_1.useEffect)(() => {
        const currentRef = ref.current;
        if (!currentRef) {
            return;
        }
        const { current } = timeline_refs_1.timelineVerticalScroll;
        if (!current) {
            return;
        }
        const onScroll = () => {
            currentRef.style.top = current.scrollTop + 'px';
        };
        current.addEventListener('scroll', onScroll);
        return () => {
            current.removeEventListener('scroll', onScroll);
        };
    }, []);
    const style = (0, react_1.useMemo)(() => {
        return {
            ...container,
            width: windowWidth,
            overflow: 'hidden',
        };
    }, [windowWidth]);
    const ticks = (0, react_1.useMemo)(() => {
        if (!video) {
            return [];
        }
        const frameInterval = (0, timeline_scroll_logic_1.getFrameIncrementFromWidth)(video.durationInFrames, windowWidth);
        const MIN_SPACING_BETWEEN_TICKS_PX = 5;
        const seconds = Math.floor(video.durationInFrames / video.fps);
        const secondMarkerEveryNth = Math.ceil((MIN_SPACING_BETWEEN_TICKS_PX * video.fps) / (frameInterval * video.fps));
        const frameMarkerEveryNth = Math.ceil(MIN_SPACING_BETWEEN_TICKS_PX / frameInterval);
        // Big ticks showing for every second
        const secondTicks = new Array(seconds)
            .fill(true)
            .map((_, index) => {
            return {
                frame: index * video.fps,
                style: {
                    ...secondTick,
                    left: frameInterval * index * video.fps + timeline_layout_1.TIMELINE_PADDING,
                },
                showTime: index > 0,
            };
        })
            .filter((_, idx) => idx % secondMarkerEveryNth === 0);
        const frameTicks = new Array(video.durationInFrames)
            .fill(true)
            .map((_, index) => {
            return {
                frame: index,
                style: {
                    ...tick,
                    left: frameInterval * index + timeline_layout_1.TIMELINE_PADDING,
                    height: index % video.fps === 0
                        ? 10
                        : (index / frameMarkerEveryNth) % 2 === 0
                            ? 5
                            : 2,
                },
                showTime: false,
            };
        })
            .filter((_, idx) => idx % frameMarkerEveryNth === 0);
        // Merge and deduplicate ticks
        const hasTicks = [];
        return [...secondTicks, ...frameTicks].filter((t) => {
            const alreadyUsed = hasTicks.find((ht) => ht === t.frame) !== undefined;
            hasTicks.push(t.frame);
            return !alreadyUsed;
        });
    }, [video, windowWidth]);
    if (!video) {
        return null;
    }
    return ((0, jsx_runtime_1.jsx)("div", { ref: ref, style: style, children: ticks.map((t) => {
            return ((0, jsx_runtime_1.jsx)("div", { style: t.style, children: t.showTime ? ((0, jsx_runtime_1.jsx)("div", { style: tickLabel, children: (0, render_frame_1.renderFrame)(t.frame, video.fps) })) : null }, t.frame));
        }) }));
};
exports.TimelineTimeIndicators = TimelineTimeIndicators;
