"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodDateEditor = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const colors_1 = require("../../../helpers/colors");
const layout_1 = require("../../layout");
const RemInput_1 = require("../../NewComposition/RemInput");
const ValidationMessage_1 = require("../../NewComposition/ValidationMessage");
const layout_2 = require("../layout");
const SchemaLabel_1 = require("./SchemaLabel");
const fullWidth = {
    width: '100%',
};
const explainer = {
    fontFamily: 'sans-serif',
    fontSize: 12,
    color: colors_1.VERY_LIGHT_TEXT,
    marginBottom: layout_1.SPACING_UNIT,
};
// This will do 2 things:
// - Make the calendar icon white
// Turn the input popup a dark mode input
const inputStyle = {
    colorScheme: 'dark',
};
const formatDate = (date) => {
    // Get the year, month, day, hours, minutes, seconds, and milliseconds
    const year = date.getFullYear();
    const month = date.getMonth() + 1; // Month is zero-indexed, so we add 1
    const day = date.getDate();
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    const milliseconds = date.getMilliseconds();
    // Format the date as a string
    const formattedDate = `${year}-${month.toString().padStart(2, '0')}-${day
        .toString()
        .padStart(2, '0')}T${hours.toString().padStart(2, '0')}:${minutes
        .toString()
        .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds
        .toString()
        .padStart(3, '0')}`;
    return formattedDate;
};
const ZodDateEditor = ({ jsonPath, value, setValue, showSaveButton, defaultValue, schema, compact, onSave, onRemove, }) => {
    const [localValue, setLocalValue] = (0, react_1.useState)(() => {
        return {
            value,
            zodValidation: schema.safeParse(value),
        };
    });
    const onValueChange = (0, react_1.useCallback)((newValue) => {
        const safeParse = schema.safeParse(newValue);
        const newLocalState = {
            value: newValue,
            zodValidation: safeParse,
        };
        setLocalValue(newLocalState);
        if (safeParse.success) {
            setValue(newValue);
        }
    }, [schema, setValue]);
    const onChange = (0, react_1.useCallback)((e) => {
        // React does not support e.target.valueAsDate :(
        onValueChange(new Date(e.target.value));
    }, [onValueChange]);
    const reset = (0, react_1.useCallback)(() => {
        onValueChange(defaultValue);
    }, [defaultValue, onValueChange]);
    const save = (0, react_1.useCallback)(() => {
        onSave(() => value);
    }, [onSave, value]);
    return ((0, jsx_runtime_1.jsxs)("div", { style: compact ? layout_2.narrowOption : layout_2.optionRow, children: [(0, jsx_runtime_1.jsx)(SchemaLabel_1.SchemaLabel, { compact: compact, isDefaultValue: value.getTime() === defaultValue.getTime(), jsonPath: jsonPath, onReset: reset, onSave: save, showSaveButton: showSaveButton, onRemove: onRemove }), (0, jsx_runtime_1.jsxs)("div", { style: fullWidth, children: [(0, jsx_runtime_1.jsx)(RemInput_1.RemotionInput, { value: formatDate(localValue.value), type: "datetime-local", status: localValue.zodValidation.success ? 'ok' : 'error', placeholder: jsonPath.join('.'), onChange: onChange, style: inputStyle }), (0, jsx_runtime_1.jsx)(layout_1.Spacing, { y: 1, block: true }), (0, jsx_runtime_1.jsx)("div", { style: explainer, children: "Date is in local format" }), !localValue.zodValidation.success && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(layout_1.Spacing, { y: 1, block: true }), (0, jsx_runtime_1.jsx)(ValidationMessage_1.ValidationMessage, { align: "flex-end", message: localValue.zodValidation.error.format()._errors[0], type: "error" })] }))] })] }));
};
exports.ZodDateEditor = ZodDateEditor;
