"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodNumberEditor = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const layout_1 = require("../../layout");
const InputDragger_1 = require("../../NewComposition/InputDragger");
const ValidationMessage_1 = require("../../NewComposition/ValidationMessage");
const layout_2 = require("../layout");
const SchemaLabel_1 = require("./SchemaLabel");
const fullWidth = {
    width: '100%',
};
const getMinValue = (schema) => {
    const minCheck = schema._def.checks.find((c) => c.kind === 'min');
    if (!minCheck) {
        return -Infinity;
    }
    if (minCheck.kind !== 'min') {
        throw new Error('Expected min check');
    }
    if (!minCheck.inclusive) {
        return -Infinity;
    }
    return minCheck.value;
};
const getMaxValue = (schema) => {
    const maxCheck = schema._def.checks.find((c) => c.kind === 'max');
    if (!maxCheck) {
        return Infinity;
    }
    if (maxCheck.kind !== 'max') {
        throw new Error('Expected max check');
    }
    if (!maxCheck.inclusive) {
        return Infinity;
    }
    return maxCheck.value;
};
const getStep = (schema) => {
    const multipleStep = schema._def.checks.find((c) => c.kind === 'multipleOf');
    if (!multipleStep) {
        return undefined;
    }
    if (multipleStep.kind !== 'multipleOf') {
        throw new Error('Expected multipleOf check');
    }
    return multipleStep.value;
};
const ZodNumberEditor = ({ jsonPath, value, schema, setValue, onSave, compact, defaultValue, onRemove, showSaveButton, }) => {
    const [localValue, setLocalValue] = (0, react_1.useState)(() => {
        return {
            value: String(value),
            zodValidation: schema.safeParse(value),
        };
    });
    const onChange = (0, react_1.useCallback)((newValue) => {
        const safeParse = schema.safeParse(Number(newValue));
        const newLocalState = {
            value: newValue,
            zodValidation: safeParse,
        };
        setLocalValue(newLocalState);
        if (safeParse.success) {
            setValue(Number(newValue));
        }
    }, [schema, setValue]);
    const onValueChange = (0, react_1.useCallback)((newValue) => {
        const safeParse = schema.safeParse(newValue);
        const newLocalState = {
            value: String(newValue),
            zodValidation: safeParse,
        };
        setLocalValue(newLocalState);
        if (safeParse.success) {
            setValue(newValue);
        }
    }, [schema, setValue]);
    // TODO: Error message does not align well
    const isDefault = value === defaultValue;
    const reset = (0, react_1.useCallback)(() => {
        onValueChange(defaultValue);
    }, [defaultValue, onValueChange]);
    const save = (0, react_1.useCallback)(() => {
        onSave(() => value);
    }, [onSave, value]);
    return ((0, jsx_runtime_1.jsxs)("div", { style: compact ? layout_2.narrowOption : layout_2.optionRow, children: [(0, jsx_runtime_1.jsx)(SchemaLabel_1.SchemaLabel, { isDefaultValue: isDefault, jsonPath: jsonPath, onReset: reset, onSave: save, showSaveButton: showSaveButton, compact: compact, onRemove: onRemove }), (0, jsx_runtime_1.jsxs)("div", { style: fullWidth, children: [(0, jsx_runtime_1.jsx)(InputDragger_1.InputDragger, { type: 'number', value: localValue.value, style: fullWidth, status: localValue.zodValidation.success ? 'ok' : 'error', placeholder: jsonPath.join('.'), onTextChange: onChange, onValueChange: onValueChange, min: getMinValue(schema), max: getMaxValue(schema), step: getStep(schema) }), !localValue.zodValidation.success && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(layout_1.Spacing, { y: 1, block: true }), (0, jsx_runtime_1.jsx)(ValidationMessage_1.ValidationMessage, { align: "flex-end", message: localValue.zodValidation.error.format()._errors[0], type: "error" })] }))] })] }));
};
exports.ZodNumberEditor = ZodNumberEditor;
