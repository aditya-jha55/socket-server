"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = void 0;
const renderer_1 = require("@remotion/renderer");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const remotion_1 = require("remotion");
const chalk_1 = require("./chalk");
const cleanup_before_quit_1 = require("./cleanup-before-quit");
const config_1 = require("./config");
const entry_point_1 = require("./entry-point");
const get_audio_codec_1 = require("./get-audio-codec");
const get_cli_options_1 = require("./get-cli-options");
const get_composition_with_dimension_override_1 = require("./get-composition-with-dimension-override");
const get_filename_1 = require("./get-filename");
const get_render_media_options_1 = require("./get-render-media-options");
const image_formats_1 = require("./image-formats");
const log_1 = require("./log");
const parse_command_line_1 = require("./parse-command-line");
const progress_bar_1 = require("./progress-bar");
const setup_cache_1 = require("./setup-cache");
const user_passed_output_location_1 = require("./user-passed-output-location");
const render = async (remotionRoot, args) => {
    const startTime = Date.now();
    const { file, remainingArgs, reason: entryPointReason, } = (0, entry_point_1.findEntryPoint)(args, remotionRoot);
    if (!file) {
        log_1.Log.error('No entry point specified. Pass more arguments:');
        log_1.Log.error('   npx remotion render [entry-point] [composition-name] [out-name]');
        log_1.Log.error('Documentation: https://www.remotion.dev/docs/render');
        process.exit(1);
    }
    const downloadMap = renderer_1.RenderInternals.makeDownloadMap();
    (0, cleanup_before_quit_1.registerCleanupJob)(() => renderer_1.RenderInternals.cleanDownloadMap(downloadMap));
    if (parse_command_line_1.parsedCli.frame) {
        log_1.Log.error('--frame flag was passed to the `render` command. This flag only works with the `still` command. Did you mean `--frames`? See reference: https://www.remotion.dev/docs/cli/');
        process.exit(1);
    }
    log_1.Log.verbose('Asset dirs', downloadMap.assetDir);
    const { concurrency, frameRange, shouldOutputImageSequence, overwrite, inputProps, envVariables, quality, browser, browserExecutable, ffmpegExecutable, ffprobeExecutable, scale, chromiumOptions, port, everyNthFrame, puppeteerTimeout, publicDir, height, width, } = await (0, get_cli_options_1.getCliOptions)({
        isLambda: false,
        type: 'series',
        remotionRoot,
    });
    const ffmpegVersion = await renderer_1.RenderInternals.getFfmpegVersion({
        ffmpegExecutable,
        remotionRoot,
    });
    log_1.Log.verbose('FFMPEG Version:', ffmpegVersion ? ffmpegVersion.join('.') : 'Built from source');
    log_1.Log.verbose('Browser executable: ', browserExecutable);
    const browserInstance = (0, renderer_1.openBrowser)(browser, {
        browserExecutable,
        shouldDumpIo: renderer_1.RenderInternals.isEqualOrBelowLogLevel(config_1.ConfigInternals.Logging.getLogLevel(), 'verbose'),
        chromiumOptions,
        forceDeviceScaleFactor: scale,
    });
    const steps = [
        renderer_1.RenderInternals.isServeUrl(file) ? null : 'bundling',
        'rendering',
        shouldOutputImageSequence ? null : 'stitching',
    ].filter(remotion_1.Internals.truthy);
    const { urlOrBundle, cleanup: cleanupBundle } = await (0, setup_cache_1.bundleOnCliOrTakeServeUrl)({
        fullPath: file,
        remotionRoot,
        steps,
        publicDir,
    });
    (0, cleanup_before_quit_1.registerCleanupJob)(() => cleanupBundle());
    const onDownload = (src) => {
        const id = Math.random();
        const download = {
            id,
            name: src,
            progress: 0,
            downloaded: 0,
            totalBytes: null,
        };
        downloads.push(download);
        updateRenderProgress();
        return ({ percent, downloaded, totalSize }) => {
            download.progress = percent;
            download.totalBytes = totalSize;
            download.downloaded = downloaded;
            updateRenderProgress();
        };
    };
    const puppeteerInstance = await browserInstance;
    const comps = await (0, renderer_1.getCompositions)(urlOrBundle, {
        inputProps,
        puppeteerInstance,
        envVariables,
        timeoutInMilliseconds: puppeteerTimeout,
        chromiumOptions,
        browserExecutable,
        downloadMap,
        port,
    });
    const { compositionId, config, reason, argsAfterComposition } = await (0, get_composition_with_dimension_override_1.getCompositionWithDimensionOverride)({
        validCompositions: comps,
        height,
        width,
        args: remainingArgs,
    });
    const { codec, reason: codecReason } = (0, get_cli_options_1.getFinalCodec)({
        downloadName: null,
        outName: (0, user_passed_output_location_1.getUserPassedOutputLocation)(argsAfterComposition),
    });
    await (0, get_cli_options_1.validateFfmpegCanUseCodec)(codec, remotionRoot);
    renderer_1.RenderInternals.validateEvenDimensionsWithCodec({
        width: config.width,
        height: config.height,
        codec,
        scale,
    });
    const audioCodec = (0, get_audio_codec_1.getResolvedAudioCodec)();
    const relativeOutputLocation = (0, get_filename_1.getOutputFilename)({
        imageSequence: shouldOutputImageSequence,
        compositionName: compositionId,
        defaultExtension: renderer_1.RenderInternals.getFileExtensionFromCodec(codec, audioCodec),
        args: argsAfterComposition,
    });
    log_1.Log.info(chalk_1.chalk.gray(`Entry point = ${path_1.default.relative(process.cwd(), file)} (${entryPointReason}), Composition = ${compositionId} (${reason}), Codec = ${codec} (${codecReason}), Output = ${relativeOutputLocation}`));
    const absoluteOutputFile = (0, get_cli_options_1.getAndValidateAbsoluteOutputFile)(relativeOutputLocation, overwrite);
    const outputDir = shouldOutputImageSequence
        ? { dir: absoluteOutputFile, cleanup: false }
        : {
            dir: await fs_1.default.promises.mkdtemp(path_1.default.join(os_1.default.tmpdir(), 'react-motion-render')),
            cleanup: true,
        };
    if (outputDir.cleanup) {
        (0, cleanup_before_quit_1.registerCleanupJob)(() => renderer_1.RenderInternals.deleteDirectory(outputDir.dir));
    }
    log_1.Log.verbose('Output dir', outputDir.dir);
    const renderProgress = (0, progress_bar_1.createOverwriteableCliOutput)((0, parse_command_line_1.quietFlagProvided)());
    const realFrameRange = renderer_1.RenderInternals.getRealFrameRange(config.durationInFrames, frameRange);
    const totalFrames = renderer_1.RenderInternals.getFramesToRender(realFrameRange, everyNthFrame);
    let encodedFrames = 0;
    let renderedFrames = 0;
    let encodedDoneIn = null;
    let renderedDoneIn = null;
    let stitchStage = 'encoding';
    const downloads = [];
    const updateRenderProgress = () => {
        if (totalFrames.length === 0) {
            throw new Error('totalFrames should not be 0');
        }
        return renderProgress.update((0, progress_bar_1.makeRenderingAndStitchingProgress)({
            rendering: {
                frames: renderedFrames,
                totalFrames: totalFrames.length,
                concurrency: renderer_1.RenderInternals.getActualConcurrency(concurrency),
                doneIn: renderedDoneIn,
                steps,
            },
            stitching: shouldOutputImageSequence
                ? null
                : {
                    doneIn: encodedDoneIn,
                    frames: encodedFrames,
                    stage: stitchStage,
                    steps,
                    totalFrames: totalFrames.length,
                    codec,
                },
            downloads,
        }));
    };
    const imageFormat = (0, image_formats_1.getImageFormat)(shouldOutputImageSequence ? undefined : codec);
    if (shouldOutputImageSequence) {
        fs_1.default.mkdirSync(absoluteOutputFile, {
            recursive: true,
        });
        if (imageFormat === 'none') {
            log_1.Log.error('Cannot render an image sequence with a codec that renders no images.');
            log_1.Log.error(`codec = ${codec}, imageFormat = ${imageFormat}`);
            process.exit(1);
        }
        await (0, renderer_1.renderFrames)({
            config,
            imageFormat,
            inputProps,
            onFrameUpdate: (rendered) => {
                renderedFrames = rendered;
                updateRenderProgress();
            },
            onStart: () => undefined,
            onDownload: (src) => {
                if (src.startsWith('data:')) {
                    log_1.Log.info('\nWriting Data URL to file: ', src.substring(0, 30) + '...');
                }
                else {
                    log_1.Log.info('\nDownloading asset... ', src);
                }
            },
            outputDir: outputDir.dir,
            serveUrl: urlOrBundle,
            dumpBrowserLogs: renderer_1.RenderInternals.isEqualOrBelowLogLevel(config_1.ConfigInternals.Logging.getLogLevel(), 'verbose'),
            everyNthFrame,
            envVariables,
            frameRange,
            concurrency,
            puppeteerInstance,
            quality,
            timeoutInMilliseconds: puppeteerTimeout,
            chromiumOptions,
            scale,
            ffmpegExecutable,
            ffprobeExecutable,
            browserExecutable,
            port,
            downloadMap,
        });
        renderedDoneIn = Date.now() - startTime;
        updateRenderProgress();
        log_1.Log.info();
        log_1.Log.info();
        log_1.Log.info(chalk_1.chalk.green('\nYour image sequence is ready!'));
        log_1.Log.info(chalk_1.chalk.cyan(`▶ ${absoluteOutputFile}`));
        return;
    }
    const options = await (0, get_render_media_options_1.getRenderMediaOptions)({
        config,
        outputLocation: absoluteOutputFile,
        serveUrl: urlOrBundle,
        codec,
        remotionRoot,
    });
    await (0, renderer_1.renderMedia)({
        ...options,
        onProgress: (update) => {
            encodedDoneIn = update.encodedDoneIn;
            encodedFrames = update.encodedFrames;
            renderedDoneIn = update.renderedDoneIn;
            stitchStage = update.stitchStage;
            renderedFrames = update.renderedFrames;
            updateRenderProgress();
        },
        puppeteerInstance,
        onDownload,
        internal: {
            downloadMap,
            onCtrlCExit: cleanup_before_quit_1.registerCleanupJob,
        },
        onSlowestFrames: (slowestFrames) => {
            log_1.Log.verbose();
            log_1.Log.verbose(`Slowest frames:`);
            slowestFrames.forEach(({ frame, time }) => {
                log_1.Log.verbose(`Frame ${frame} (${time.toFixed(3)}ms)`);
            });
        },
    });
    log_1.Log.info();
    log_1.Log.info();
    const seconds = Math.round((Date.now() - startTime) / 1000);
    log_1.Log.info([
        '- Total render time:',
        seconds,
        seconds === 1 ? 'second' : 'seconds',
    ].join(' '));
    log_1.Log.info('-', 'Output can be found at:');
    log_1.Log.info(chalk_1.chalk.cyan(`▶ ${absoluteOutputFile}`));
    log_1.Log.info(chalk_1.chalk.green(`\nYour ${codec === 'gif' ? 'GIF' : 'video'} is ready!`));
    if (renderer_1.RenderInternals.isEqualOrBelowLogLevel(config_1.ConfigInternals.Logging.getLogLevel(), 'verbose')) {
        renderer_1.RenderInternals.perf.logPerf();
    }
};
exports.render = render;
