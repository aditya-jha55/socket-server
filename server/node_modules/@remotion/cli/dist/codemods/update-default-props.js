"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDefaultProps = void 0;
const findStarter = ({ input, compositionId, }) => {
    const format1 = input.indexOf(`id="${compositionId}"`);
    if (format1 > -1) {
        return format1;
    }
    const format2 = input.indexOf(`id='${compositionId}'`);
    if (format2 > -1) {
        return format2;
    }
    const format3 = input.indexOf(`id={'${compositionId}'}`);
    if (format3 > -1) {
        return format3;
    }
    const format4 = input.indexOf(`id={"${compositionId}"}`);
    if (format4 > -1) {
        return format4;
    }
    const format5 = input.indexOf(`id={\`${compositionId}\``);
    if (format5 > -1) {
        return format5;
    }
    throw new Error(`Could not find composition ID ${compositionId} in file`);
};
const findEndPosition = (input, currentPosition) => {
    const asConstVersion = input
        .slice(currentPosition + 1)
        .search(/as\sconst[ \t\n\r]+\}/);
    if (asConstVersion !== -1) {
        const nextEnd = input.indexOf('}', asConstVersion + currentPosition + 1);
        return nextEnd - 1;
    }
    const next = input.indexOf('}}', currentPosition + 1);
    if (next !== -1) {
        return next;
    }
    throw new Error('Could not find end of defaultProps');
};
const findEnder = (input, position, maxPosition) => {
    let currentPosition = position;
    while (currentPosition < maxPosition) {
        const next = findEndPosition(input, currentPosition);
        currentPosition = next;
        const nextChar = input[next + 1];
        if (nextChar === ',') {
            continue;
        }
        return [position, currentPosition + 1];
    }
    throw new Error('did not find string');
};
const findTerminators = (input, position) => {
    const nextComposition = input.indexOf('<Composition', position);
    if (nextComposition > -1) {
        return nextComposition;
    }
    const nextStill = input.indexOf('<Still', position);
    if (nextStill > -1) {
        return nextStill;
    }
    return Infinity;
};
const stringifyDefaultProps = (props) => {
    // Don't replace with arrow function
    return JSON.stringify(props, function (key, value) {
        if (this[key] instanceof Date) {
            return `__REMOVEQUOTE__new Date('${new Date(this[key]).toISOString()}')__REMOVEQUOTE__`;
        }
        if (typeof this[key] === 'string') {
            return `${this[key]}__ADD_AS_CONST__`;
        }
        return value;
    })
        .replace(/"__REMOVEQUOTE__/g, '')
        .replace(/__REMOVEQUOTE__"/g, '')
        .replace(/__ADD_AS_CONST__"/g, '" as const');
};
// TODO: Add more sanity checks
// TODO: better error messages
const updateDefaultProps = async ({ input, compositionId, newDefaultProps, }) => {
    const starter = findStarter({ input, compositionId });
    const START_TOKEN = 'defaultProps={';
    const start = input.indexOf(START_TOKEN, starter);
    if (start === -1) {
        throw new Error('Could not find defaultProps in <Composition> tag');
    }
    const maxEnd = findTerminators(input, starter);
    const [startPos, endPos] = findEnder(input, start + START_TOKEN.length, maxEnd);
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    let prettier = null;
    try {
        prettier = await Promise.resolve().then(() => __importStar(require('prettier')));
    }
    catch (err) {
        throw new Error('Cannot save default props because Prettier cannot be found in the current project.');
    }
    const { format, resolveConfig, resolveConfigFile } = prettier;
    const newFile = input.substring(0, startPos) +
        stringifyDefaultProps(newDefaultProps) +
        input.substring(endPos);
    const configFilePath = await resolveConfigFile();
    if (!configFilePath) {
        throw new Error('prettier config file not found');
    }
    const prettierConfig = await resolveConfig(configFilePath);
    if (!prettierConfig) {
        throw new Error('Prettier config not found');
    }
    const prettified = format(newFile, {
        ...prettierConfig,
        rangeStart: startPos,
        rangeEnd: endPos,
        filepath: 'test.tsx',
        plugins: [],
        endOfLine: 'auto',
    });
    return prettified;
};
exports.updateDefaultProps = updateDefaultProps;
