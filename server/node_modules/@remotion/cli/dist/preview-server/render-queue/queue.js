"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processJobIfPossible = exports.cancelJob = exports.removeJob = exports.addJob = exports.processJob = exports.notifyClientsOfJobUpdate = exports.getRenderQueue = void 0;
const path_1 = __importDefault(require("path"));
const chalk_1 = require("../../chalk");
const file_watcher_1 = require("../../file-watcher");
const handle_common_errors_1 = require("../../handle-common-errors");
const log_1 = require("../../log");
const progress_types_1 = require("../../progress-types");
const live_events_1 = require("../live-events");
const process_still_1 = require("./process-still");
const process_video_1 = require("./process-video");
let jobQueue = [];
const updateJob = (id, updater) => {
    jobQueue = jobQueue.map((j) => {
        if (id === j.id) {
            return updater(j);
        }
        return j;
    });
    (0, exports.notifyClientsOfJobUpdate)();
};
const getRenderQueue = () => {
    return jobQueue.map((j) => {
        const { cleanup, ...rest } = j;
        return rest;
    });
};
exports.getRenderQueue = getRenderQueue;
const notifyClientsOfJobUpdate = () => {
    (0, live_events_1.waitForLiveEventsListener)().then((listener) => {
        listener.sendEventToClient({
            type: 'render-queue-updated',
            queue: (0, exports.getRenderQueue)(),
        });
    });
};
exports.notifyClientsOfJobUpdate = notifyClientsOfJobUpdate;
const processJob = async ({ job, remotionRoot, entryPoint, onProgress, addCleanupCallback, }) => {
    if (job.type === 'still') {
        await (0, process_still_1.processStill)({
            job,
            remotionRoot,
            entryPoint,
            onProgress,
            addCleanupCallback,
        });
        return;
    }
    if (job.type === 'video') {
        await (0, process_video_1.processVideoJob)({
            job,
            remotionRoot,
            entryPoint,
            onProgress,
            addCleanupCallback,
        });
        return;
    }
    throw new Error(`Unknown job ${JSON.stringify(job)}`);
};
exports.processJob = processJob;
const addJob = ({ job, entryPoint, remotionRoot, }) => {
    jobQueue.push(job);
    (0, exports.processJobIfPossible)({ entryPoint, remotionRoot });
    (0, exports.notifyClientsOfJobUpdate)();
};
exports.addJob = addJob;
const removeJob = (jobId) => {
    jobQueue = jobQueue.filter((job) => {
        if (job.id === jobId) {
            job.cleanup.forEach((c) => {
                c();
            });
            return false;
        }
        return true;
    });
    (0, exports.notifyClientsOfJobUpdate)();
};
exports.removeJob = removeJob;
const cancelJob = (jobId) => {
    for (const job of jobQueue) {
        if (job.id === jobId) {
            if (job.status !== 'running') {
                throw new Error('Job is not running');
            }
            job.cancelToken.cancel();
            break;
        }
    }
};
exports.cancelJob = cancelJob;
// TODO: Currently, concurrency = 1 is not enforced
const processJobIfPossible = async ({ remotionRoot, entryPoint, }) => {
    const nextJob = jobQueue.find((q) => {
        return q.status === 'idle';
    });
    if (!nextJob) {
        return;
    }
    const jobCleanups = [];
    try {
        updateJob(nextJob.id, (job) => {
            return {
                ...job,
                status: 'running',
                progress: {
                    value: 0,
                    message: 'Starting job...',
                    ...(0, progress_types_1.initialAggregateRenderProgress)(),
                },
            };
        });
        const startTime = Date.now();
        log_1.Log.info(chalk_1.chalk.gray('╭─ Starting render '));
        let lastProgress = null;
        await (0, exports.processJob)({
            job: nextJob,
            entryPoint,
            remotionRoot,
            onProgress: (progress) => {
                updateJob(nextJob.id, (job) => {
                    lastProgress = progress;
                    // Ignore late callbacks of progress updates after cancelling
                    if (job.status === 'failed' || job.status === 'done') {
                        return job;
                    }
                    if (job.type === 'still') {
                        return {
                            ...job,
                            status: 'running',
                            progress,
                        };
                    }
                    if (job.type === 'video') {
                        return {
                            ...job,
                            status: 'running',
                            progress,
                        };
                    }
                    throw new Error('Unknown job type');
                });
            },
            addCleanupCallback: (cleanup) => {
                jobCleanups.push(cleanup);
            },
        });
        log_1.Log.info(chalk_1.chalk.gray('╰─ Done in ' + (Date.now() - startTime) + 'ms.'));
        const { unwatch } = (0, file_watcher_1.installFileWatcher)({
            file: path_1.default.resolve(remotionRoot, nextJob.outName),
            onChange: (type) => {
                if (type === 'created') {
                    updateJob(nextJob.id, (job) => ({
                        ...job,
                        deletedOutputLocation: false,
                    }));
                }
                if (type === 'deleted') {
                    updateJob(nextJob.id, (job) => ({
                        ...job,
                        deletedOutputLocation: true,
                    }));
                }
            },
        });
        updateJob(nextJob.id, (job) => {
            if (!lastProgress) {
                throw new Error('expected progress');
            }
            return {
                ...job,
                status: 'done',
                cleanup: [...job.cleanup, unwatch],
                progress: { message: 'Done', value: 1, ...lastProgress },
            };
        });
    }
    catch (err) {
        log_1.Log.error(chalk_1.chalk.gray('╰─ '), chalk_1.chalk.red('Failed to render'));
        updateJob(nextJob.id, (job) => {
            return {
                ...job,
                status: 'failed',
                error: {
                    message: err.message,
                    stack: err.stack,
                },
            };
        });
        await (0, handle_common_errors_1.handleCommonError)(err);
        (0, live_events_1.waitForLiveEventsListener)().then((listener) => {
            listener.sendEventToClient({
                type: 'render-job-failed',
                compositionId: nextJob.compositionId,
                error: err,
            });
        });
    }
    finally {
        await Promise.all(jobCleanups.map((c) => c()));
    }
};
exports.processJobIfPossible = processJobIfPossible;
