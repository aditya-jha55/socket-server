"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.previewCommand = void 0;
const crypto_1 = __importDefault(require("crypto"));
const path_1 = __importDefault(require("path"));
const better_opn_1 = require("./better-opn");
const chalk_1 = require("./chalk");
const config_1 = require("./config");
const entry_point_1 = require("./entry-point");
const get_env_1 = require("./get-env");
const get_input_props_1 = require("./get-input-props");
const get_network_address_1 = require("./get-network-address");
const log_1 = require("./log");
const parse_command_line_1 = require("./parse-command-line");
const get_absolute_public_dir_1 = require("./preview-server/get-absolute-public-dir");
const public_folder_1 = require("./preview-server/public-folder");
const start_server_1 = require("./preview-server/start-server");
const noop = () => undefined;
let liveEventsListener = null;
const waiters = [];
const setLiveEventsListener = (listener) => {
    liveEventsListener = listener;
    waiters.forEach((w) => w(listener));
};
const waitForLiveEventsListener = () => {
    if (liveEventsListener) {
        return Promise.resolve(liveEventsListener);
    }
    return new Promise((resolve) => {
        waiters.push((list) => {
            resolve(list);
        });
    });
};
const getShouldOpenBrowser = () => {
    var _a;
    if (parse_command_line_1.parsedCli['no-open']) {
        return {
            shouldOpenBrowser: false,
            reasonForBrowserDecision: '--no-open specified',
        };
    }
    if (((_a = process.env.BROWSER) !== null && _a !== void 0 ? _a : '').toLowerCase() === 'none') {
        return {
            shouldOpenBrowser: false,
            reasonForBrowserDecision: 'env BROWSER=none was set',
        };
    }
    if (config_1.ConfigInternals.getShouldOpenBrowser() === false) {
        return { shouldOpenBrowser: false, reasonForBrowserDecision: 'Config file' };
    }
    return { shouldOpenBrowser: true, reasonForBrowserDecision: 'default' };
};
const getPort = () => {
    if (parse_command_line_1.parsedCli.port) {
        return parse_command_line_1.parsedCli.port;
    }
    const serverPort = config_1.ConfigInternals.getServerPort();
    if (serverPort) {
        return serverPort;
    }
    return null;
};
const previewCommand = async (remotionRoot, args) => {
    const { file, reason } = (0, entry_point_1.findEntryPoint)(args, remotionRoot);
    log_1.Log.verbose('Entry point:', file, 'reason:', reason);
    if (!file) {
        log_1.Log.error('The preview command requires you to specify a root file. For example');
        log_1.Log.error('  npx remotion preview src/index.ts');
        log_1.Log.error('See https://www.remotion.dev/docs/register-root for more information.');
        process.exit(1);
    }
    const desiredPort = getPort();
    let inputProps = (0, get_input_props_1.getInputProps)((newProps) => {
        waitForLiveEventsListener().then((listener) => {
            inputProps = newProps;
            listener.sendEventToClient({
                type: 'new-input-props',
                newProps,
            });
        });
    });
    let envVariables = await (0, get_env_1.getEnvironmentVariables)((newEnvVariables) => {
        waitForLiveEventsListener().then((listener) => {
            envVariables = newEnvVariables;
            listener.sendEventToClient({
                type: 'new-env-variables',
                newEnvVariables,
            });
        });
    });
    const publicDir = (0, get_absolute_public_dir_1.getAbsolutePublicDir)({
        userPassedPublicDir: config_1.ConfigInternals.getPublicDir(),
        remotionRoot,
    });
    const hashPrefix = '/static-';
    const staticHash = `${hashPrefix}${crypto_1.default.randomBytes(6).toString('hex')}`;
    (0, public_folder_1.initPublicFolderWatch)({
        publicDir,
        remotionRoot,
        onUpdate: () => {
            waitForLiveEventsListener().then((listener) => {
                listener.sendEventToClient({
                    type: 'new-public-folder',
                    files: (0, public_folder_1.getFiles)(),
                });
            });
        },
        staticHash,
    });
    const { port, liveEventsServer } = await (0, start_server_1.startServer)({
        entry: path_1.default.resolve(__dirname, 'previewEntry.js'),
        userDefinedComponent: file,
        getCurrentInputProps: () => inputProps,
        getEnvVariables: () => envVariables,
        port: desiredPort,
        maxTimelineTracks: config_1.ConfigInternals.getMaxTimelineTracks(),
        remotionRoot,
        keyboardShortcutsEnabled: config_1.ConfigInternals.getKeyboardShortcutsEnabled(),
        publicDir,
        webpackOverride: config_1.ConfigInternals.getWebpackOverrideFn(),
        poll: config_1.ConfigInternals.getWebpackPolling(),
        userPassedPublicDir: config_1.ConfigInternals.getPublicDir(),
        hash: staticHash,
        hashPrefix,
    });
    setLiveEventsListener(liveEventsServer);
    const networkAddress = (0, get_network_address_1.getNetworkAddress)();
    if (networkAddress) {
        log_1.Log.info(`Server ready - Local: ${chalk_1.chalk.underline(`http://localhost:${port}`)}, Network: ${chalk_1.chalk.underline(`http://${networkAddress}:${port}`)}`);
    }
    else {
        log_1.Log.info(`Running on http://localhost:${port}`);
    }
    const { reasonForBrowserDecision, shouldOpenBrowser } = getShouldOpenBrowser();
    if (shouldOpenBrowser) {
        await (0, better_opn_1.openBrowser)({
            url: `http://localhost:${port}`,
            browserArgs: parse_command_line_1.parsedCli['browser-args'],
            browserFlag: parse_command_line_1.parsedCli.browser,
        });
    }
    else {
        log_1.Log.verbose(`Not opening browser, reason: ${reasonForBrowserDecision}`);
    }
    await new Promise(noop);
};
exports.previewCommand = previewCommand;
