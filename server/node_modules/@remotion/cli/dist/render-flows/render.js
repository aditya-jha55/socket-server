"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderVideoFlow = void 0;
const renderer_1 = require("@remotion/renderer");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const chalk_1 = require("../chalk");
const config_1 = require("../config");
const get_cli_options_1 = require("../get-cli-options");
const get_composition_with_dimension_override_1 = require("../get-composition-with-dimension-override");
const get_filename_1 = require("../get-filename");
const get_final_output_codec_1 = require("../get-final-output-codec");
const image_formats_1 = require("../image-formats");
const log_1 = require("../log");
const parse_command_line_1 = require("../parse-command-line");
const progress_bar_1 = require("../progress-bar");
const setup_cache_1 = require("../setup-cache");
const truthy_1 = require("../truthy");
const user_passed_output_location_1 = require("../user-passed-output-location");
const renderVideoFlow = async ({ remotionRoot, fullEntryPoint, indent, logLevel, browserExecutable, browser, chromiumOptions, scale, shouldOutputImageSequence, publicDir, inputProps, envVariables, puppeteerTimeout, port, height, width, remainingArgs, compositionIdFromUi, entryPointReason, overwrite, quiet, concurrency, frameRange, everyNthFrame, outputLocationFromUI, quality, onProgress, addCleanupCallback, cancelSignal, crf, uiCodec, uiImageFormat, ffmpegOverride, audioBitrate, muted, enforceAudioTrack, proResProfile, pixelFormat, videoBitrate, numberOfGifLoops, audioCodec, disallowParallelEncoding, }) => {
    var _a;
    const downloads = [];
    const downloadMap = renderer_1.RenderInternals.makeDownloadMap();
    addCleanupCallback(() => renderer_1.RenderInternals.cleanDownloadMap(downloadMap));
    log_1.Log.verboseAdvanced({ indent, logLevel }, 'Browser executable: ', browserExecutable);
    log_1.Log.verboseAdvanced({ indent, logLevel }, 'Asset dirs', downloadMap.assetDir);
    const browserInstance = (0, renderer_1.openBrowser)(browser, {
        browserExecutable,
        shouldDumpIo: renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'verbose'),
        chromiumOptions,
        forceDeviceScaleFactor: scale,
        indentationString: indent ? log_1.INDENT_TOKEN + ' ' : '',
    });
    const renderProgress = (0, progress_bar_1.createOverwriteableCliOutput)({
        quiet,
        cancelSignal,
    });
    const steps = [
        renderer_1.RenderInternals.isServeUrl(fullEntryPoint) ? null : 'bundling',
        'rendering',
        shouldOutputImageSequence ? null : 'stitching',
    ].filter(truthy_1.truthy);
    let bundlingProgress = {
        doneIn: null,
        progress: 0,
    };
    let renderingProgress = null;
    let stitchingProgress = null;
    let copyingState = {
        bytes: 0,
        doneIn: null,
    };
    const updateRenderProgress = () => {
        const aggregateRenderProgress = {
            rendering: renderingProgress,
            stitching: shouldOutputImageSequence ? null : stitchingProgress,
            downloads,
            bundling: bundlingProgress,
            copyingState,
        };
        const { output, message, progress } = (0, progress_bar_1.makeRenderingAndStitchingProgress)({
            prog: aggregateRenderProgress,
            indent,
            steps: steps.length,
            stitchingStep: steps.indexOf('bundling'),
        });
        onProgress({ message, value: progress, ...aggregateRenderProgress });
        return renderProgress.update(output);
    };
    const { urlOrBundle, cleanup: cleanupBundle } = await (0, setup_cache_1.bundleOnCliOrTakeServeUrl)({
        fullPath: fullEntryPoint,
        remotionRoot,
        publicDir,
        onProgress: ({ bundling, copying }) => {
            bundlingProgress = bundling;
            copyingState = copying;
            updateRenderProgress();
        },
        indentOutput: indent,
        logLevel,
        bundlingStep: steps.indexOf('bundling'),
        steps: steps.length,
    });
    addCleanupCallback(() => cleanupBundle());
    const onDownload = (src) => {
        const id = Math.random();
        const download = {
            id,
            name: src,
            progress: 0,
            downloaded: 0,
            totalBytes: null,
        };
        downloads.push(download);
        updateRenderProgress();
        return ({ percent, downloaded, totalSize }) => {
            download.progress = percent;
            download.totalBytes = totalSize;
            download.downloaded = downloaded;
            updateRenderProgress();
        };
    };
    const puppeteerInstance = await browserInstance;
    addCleanupCallback(() => puppeteerInstance.close(false));
    const comps = await (0, renderer_1.getCompositions)(urlOrBundle, {
        inputProps,
        puppeteerInstance,
        envVariables,
        timeoutInMilliseconds: puppeteerTimeout,
        chromiumOptions,
        browserExecutable,
        downloadMap,
        port,
    });
    const { compositionId, config, reason, argsAfterComposition } = await (0, get_composition_with_dimension_override_1.getCompositionWithDimensionOverride)({
        validCompositions: comps,
        height,
        width,
        args: remainingArgs,
        compositionIdFromUi,
    });
    const { codec, reason: codecReason } = (0, get_final_output_codec_1.getFinalOutputCodec)({
        cliFlag: parse_command_line_1.parsedCli.codec,
        configFile: (_a = config_1.ConfigInternals.getOutputCodecOrUndefined()) !== null && _a !== void 0 ? _a : null,
        downloadName: null,
        outName: (0, user_passed_output_location_1.getUserPassedOutputLocation)(argsAfterComposition),
        uiCodec,
    });
    renderer_1.RenderInternals.validateEvenDimensionsWithCodec({
        width: config.width,
        height: config.height,
        codec,
        scale,
    });
    const relativeOutputLocation = (0, get_filename_1.getOutputFilename)({
        imageSequence: shouldOutputImageSequence,
        compositionName: compositionId,
        defaultExtension: renderer_1.RenderInternals.getFileExtensionFromCodec(codec, audioCodec),
        args: argsAfterComposition,
        indent,
        fromUi: outputLocationFromUI,
        logLevel,
    });
    log_1.Log.infoAdvanced({ indent, logLevel }, chalk_1.chalk.gray(`Entry point = ${fullEntryPoint} (${entryPointReason}), Composition = ${compositionId} (${reason}), Codec = ${codec} (${codecReason}), Output = ${relativeOutputLocation}`));
    const absoluteOutputFile = (0, get_cli_options_1.getAndValidateAbsoluteOutputFile)(relativeOutputLocation, overwrite);
    const realFrameRange = renderer_1.RenderInternals.getRealFrameRange(config.durationInFrames, frameRange);
    const totalFrames = renderer_1.RenderInternals.getFramesToRender(realFrameRange, everyNthFrame);
    const actualConcurrency = renderer_1.RenderInternals.getActualConcurrency(concurrency);
    renderingProgress = {
        frames: 0,
        totalFrames: totalFrames.length,
        concurrency: actualConcurrency,
        doneIn: null,
        steps,
    };
    const imageFormat = (0, image_formats_1.getVideoImageFormat)({
        codec: shouldOutputImageSequence ? undefined : codec,
        uiImageFormat,
    });
    if (shouldOutputImageSequence) {
        fs_1.default.mkdirSync(absoluteOutputFile, {
            recursive: true,
        });
        if (imageFormat === 'none') {
            throw new Error(`Cannot render an image sequence with a codec that renders no images. codec = ${codec}, imageFormat = ${imageFormat}`);
        }
        const outputDir = shouldOutputImageSequence
            ? absoluteOutputFile
            : await fs_1.default.promises.mkdtemp(path_1.default.join(os_1.default.tmpdir(), 'react-motion-render'));
        log_1.Log.verboseAdvanced({ indent, logLevel }, 'Output dir', outputDir);
        await (0, renderer_1.renderFrames)({
            imageFormat,
            inputProps,
            onFrameUpdate: (rendered) => {
                renderingProgress.frames = rendered;
                updateRenderProgress();
            },
            onStart: () => undefined,
            onDownload: (src) => {
                if (src.startsWith('data:')) {
                    log_1.Log.infoAdvanced({ indent, logLevel }, '\nWriting Data URL to file: ', src.substring(0, 30) + '...');
                }
                else {
                    log_1.Log.infoAdvanced({ indent, logLevel }, '\nDownloading asset... ', src);
                }
            },
            cancelSignal: cancelSignal !== null && cancelSignal !== void 0 ? cancelSignal : undefined,
            outputDir,
            serveUrl: urlOrBundle,
            dumpBrowserLogs: renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'verbose'),
            everyNthFrame,
            envVariables,
            frameRange,
            concurrency: actualConcurrency,
            puppeteerInstance,
            quality,
            timeoutInMilliseconds: puppeteerTimeout,
            chromiumOptions,
            scale,
            browserExecutable,
            port,
            downloadMap,
            composition: config,
        });
        updateRenderProgress();
        process.stdout.write('\n');
        log_1.Log.infoAdvanced({ indent, logLevel }, chalk_1.chalk.cyan(`▶ ${absoluteOutputFile}`));
        return;
    }
    stitchingProgress = {
        doneIn: null,
        frames: 0,
        stage: 'encoding',
        totalFrames: totalFrames.length,
        codec,
    };
    const { slowestFrames } = await (0, renderer_1.renderMedia)({
        outputLocation: absoluteOutputFile,
        composition: {
            ...config,
            width: width !== null && width !== void 0 ? width : config.width,
            height: height !== null && height !== void 0 ? height : config.height,
        },
        crf,
        envVariables,
        frameRange,
        inputProps,
        overwrite,
        pixelFormat,
        proResProfile,
        quality,
        dumpBrowserLogs: renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'verbose'),
        chromiumOptions,
        timeoutInMilliseconds: config_1.ConfigInternals.getCurrentPuppeteerTimeout(),
        scale,
        port,
        numberOfGifLoops,
        everyNthFrame,
        verbose: renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'verbose'),
        muted,
        enforceAudioTrack,
        browserExecutable,
        ffmpegOverride,
        concurrency,
        serveUrl: urlOrBundle,
        codec,
        audioBitrate,
        videoBitrate,
        onProgress: (update) => {
            stitchingProgress.doneIn =
                update.encodedDoneIn;
            stitchingProgress.frames =
                update.encodedFrames;
            stitchingProgress.stage = update.stitchStage;
            renderingProgress.doneIn =
                update.renderedDoneIn;
            renderingProgress.frames =
                update.renderedFrames;
            updateRenderProgress();
        },
        puppeteerInstance,
        onDownload,
        internal: {
            onCtrlCExit: addCleanupCallback,
            downloadMap,
        },
        cancelSignal: cancelSignal !== null && cancelSignal !== void 0 ? cancelSignal : undefined,
        printLog: (...str) => log_1.Log.verboseAdvanced({ indent, logLevel }, ...str),
        audioCodec,
        preferLossless: false,
        imageFormat,
        disallowParallelEncoding,
    });
    log_1.Log.verboseAdvanced({ indent, logLevel });
    log_1.Log.verboseAdvanced({ indent, logLevel }, `Slowest frames:`);
    slowestFrames.forEach(({ frame, time }) => {
        log_1.Log.verboseAdvanced({ indent, logLevel }, `Frame ${frame} (${time.toFixed(3)}ms)`);
    });
    updateRenderProgress();
    process.stdout.write('\n');
    log_1.Log.infoAdvanced({ indent, logLevel }, chalk_1.chalk.cyan(`▶ ${absoluteOutputFile}`));
    for (const line of renderer_1.RenderInternals.perf.getPerf()) {
        log_1.Log.verboseAdvanced({ indent, logLevel }, line);
    }
};
exports.renderVideoFlow = renderVideoFlow;
