"use strict";
// Prints to CLI and also reports back to browser
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderStillFlow = void 0;
const renderer_1 = require("@remotion/renderer");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const chalk_1 = require("../chalk");
const config_1 = require("../config");
const determine_image_format_1 = require("../determine-image-format");
const get_cli_options_1 = require("../get-cli-options");
const get_composition_with_dimension_override_1 = require("../get-composition-with-dimension-override");
const log_1 = require("../log");
const parse_command_line_1 = require("../parse-command-line");
const progress_bar_1 = require("../progress-bar");
const progress_types_1 = require("../progress-types");
const setup_cache_1 = require("../setup-cache");
const truthy_1 = require("../truthy");
const user_passed_output_location_1 = require("../user-passed-output-location");
const renderStillFlow = async ({ remotionRoot, fullEntryPoint, entryPointReason, remainingArgs, browser, browserExecutable, chromiumOptions, envVariables, height, inputProps, overwrite, port, publicDir, puppeteerTimeout, quality, scale, stillFrame, width, compositionIdFromUi, imageFormatFromUi, logLevel, onProgress, indentOutput, addCleanupCallback, cancelSignal, }) => {
    var _a, _b;
    const downloads = [];
    const aggregate = (0, progress_types_1.initialAggregateRenderProgress)();
    let renderProgress = null;
    const steps = [
        renderer_1.RenderInternals.isServeUrl(fullEntryPoint) ? null : 'bundling',
        'rendering',
    ].filter(truthy_1.truthy);
    const updateProgress = () => {
        const { output, progress, message } = (0, progress_bar_1.makeRenderingAndStitchingProgress)({
            prog: aggregate,
            indent: indentOutput,
            steps: steps.length,
            stitchingStep: steps.indexOf('stitching'),
        });
        if (renderProgress) {
            renderProgress.update(output);
        }
        onProgress({ message, value: progress, ...aggregate });
    };
    log_1.Log.verboseAdvanced({ indent: indentOutput, logLevel }, 'Browser executable: ', browserExecutable);
    const shouldDumpIo = renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'verbose');
    const browserInstance = (0, renderer_1.openBrowser)(browser, {
        browserExecutable,
        chromiumOptions,
        shouldDumpIo,
        forceDeviceScaleFactor: scale,
        indentationString: indentOutput ? log_1.INDENT_TOKEN + ' ' : '',
    });
    const { cleanup: cleanupBundle, urlOrBundle } = await (0, setup_cache_1.bundleOnCliOrTakeServeUrl)({
        fullPath: fullEntryPoint,
        remotionRoot,
        steps: steps.length,
        publicDir,
        onProgress: ({ copying, bundling }) => {
            aggregate.bundling = bundling;
            aggregate.copyingState = copying;
            updateProgress();
        },
        indentOutput,
        logLevel,
        bundlingStep: steps.indexOf('bundling'),
    });
    addCleanupCallback(() => cleanupBundle());
    const puppeteerInstance = await browserInstance;
    addCleanupCallback(() => puppeteerInstance.close(false));
    const downloadMap = renderer_1.RenderInternals.makeDownloadMap();
    addCleanupCallback(() => renderer_1.RenderInternals.cleanDownloadMap(downloadMap));
    const comps = await (0, renderer_1.getCompositions)(urlOrBundle, {
        inputProps,
        puppeteerInstance,
        envVariables,
        timeoutInMilliseconds: puppeteerTimeout,
        chromiumOptions,
        port,
        browserExecutable,
        downloadMap,
    });
    const { compositionId, config, reason, argsAfterComposition } = await (0, get_composition_with_dimension_override_1.getCompositionWithDimensionOverride)({
        validCompositions: comps,
        height,
        width,
        args: remainingArgs,
        compositionIdFromUi,
    });
    const { format: imageFormat, source } = (0, determine_image_format_1.determineFinalStillImageFormat)({
        cliFlag: (_a = parse_command_line_1.parsedCli['image-format']) !== null && _a !== void 0 ? _a : null,
        configImageFormat: (_b = config_1.ConfigInternals.getUserPreferredStillImageFormat()) !== null && _b !== void 0 ? _b : null,
        downloadName: null,
        outName: (0, user_passed_output_location_1.getUserPassedOutputLocation)(argsAfterComposition),
        isLambda: false,
        fromUi: imageFormatFromUi,
    });
    const relativeOutputLocation = (0, user_passed_output_location_1.getOutputLocation)({
        compositionId,
        defaultExtension: imageFormat,
        args: argsAfterComposition,
        type: 'asset',
    });
    const absoluteOutputLocation = (0, get_cli_options_1.getAndValidateAbsoluteOutputFile)(relativeOutputLocation, overwrite);
    (0, fs_1.mkdirSync)(path_1.default.join(absoluteOutputLocation, '..'), {
        recursive: true,
    });
    log_1.Log.infoAdvanced({ indent: indentOutput, logLevel }, chalk_1.chalk.gray(`Entry point = ${fullEntryPoint} (${entryPointReason}), Output = ${relativeOutputLocation}, Format = ${imageFormat} (${source}), Composition = ${compositionId} (${reason})`));
    renderProgress = (0, progress_bar_1.createOverwriteableCliOutput)({
        quiet: (0, parse_command_line_1.quietFlagProvided)(),
        cancelSignal,
    });
    const renderStart = Date.now();
    aggregate.rendering = {
        frames: 0,
        concurrency: 1,
        doneIn: null,
        steps,
        totalFrames: 1,
    };
    updateProgress();
    const onDownload = (src) => {
        const id = Math.random();
        const download = {
            id,
            name: src,
            progress: 0,
            downloaded: 0,
            totalBytes: null,
        };
        downloads.push(download);
        updateProgress();
        return ({ percent }) => {
            download.progress = percent;
            updateProgress();
        };
    };
    await (0, renderer_1.renderStill)({
        composition: config,
        frame: stillFrame,
        output: absoluteOutputLocation,
        serveUrl: urlOrBundle,
        quality,
        dumpBrowserLogs: shouldDumpIo,
        envVariables,
        imageFormat,
        inputProps,
        chromiumOptions,
        timeoutInMilliseconds: puppeteerTimeout,
        scale,
        browserExecutable,
        overwrite,
        onDownload,
        port,
        downloadMap,
        puppeteerInstance,
    });
    aggregate.rendering = {
        frames: 1,
        concurrency: 1,
        doneIn: Date.now() - renderStart,
        steps,
        totalFrames: 1,
    };
    updateProgress();
    log_1.Log.infoAdvanced({ indent: indentOutput, logLevel });
    log_1.Log.infoAdvanced({ indent: indentOutput, logLevel }, chalk_1.chalk.cyan(`▶️ ${absoluteOutputLocation}`));
};
exports.renderStillFlow = renderStillFlow;
