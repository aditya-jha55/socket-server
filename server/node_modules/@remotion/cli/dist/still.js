"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.still = void 0;
const renderer_1 = require("@remotion/renderer");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const chalk_1 = require("./chalk");
const cleanup_before_quit_1 = require("./cleanup-before-quit");
const config_1 = require("./config");
const determine_image_format_1 = require("./determine-image-format");
const entry_point_1 = require("./entry-point");
const get_cli_options_1 = require("./get-cli-options");
const get_composition_with_dimension_override_1 = require("./get-composition-with-dimension-override");
const log_1 = require("./log");
const parse_command_line_1 = require("./parse-command-line");
const progress_bar_1 = require("./progress-bar");
const setup_cache_1 = require("./setup-cache");
const truthy_1 = require("./truthy");
const user_passed_output_location_1 = require("./user-passed-output-location");
const still = async (remotionRoot, args) => {
    var _a, _b;
    const startTime = Date.now();
    const { file, remainingArgs, reason: entryPointReason, } = (0, entry_point_1.findEntryPoint)(args, remotionRoot);
    if (!file) {
        log_1.Log.error('No entry point specified. Pass more arguments:');
        log_1.Log.error('   npx remotion render [entry-point] [composition-name] [out-name]');
        log_1.Log.error('Documentation: https://www.remotion.dev/docs/render');
        process.exit(1);
    }
    if (parse_command_line_1.parsedCli.frames) {
        log_1.Log.error('--frames flag was passed to the `still` command. This flag only works with the `render` command. Did you mean `--frame`? See reference: https://www.remotion.dev/docs/cli/');
        process.exit(1);
    }
    const { inputProps, envVariables, quality, browser, stillFrame, browserExecutable, chromiumOptions, scale, ffmpegExecutable, ffprobeExecutable, overwrite, puppeteerTimeout, port, publicDir, height, width, } = await (0, get_cli_options_1.getCliOptions)({
        isLambda: false,
        type: 'still',
        remotionRoot,
    });
    log_1.Log.verbose('Browser executable: ', browserExecutable);
    const browserInstance = (0, renderer_1.openBrowser)(browser, {
        browserExecutable,
        chromiumOptions,
        shouldDumpIo: renderer_1.RenderInternals.isEqualOrBelowLogLevel(config_1.ConfigInternals.Logging.getLogLevel(), 'verbose'),
        forceDeviceScaleFactor: scale,
    });
    const steps = [
        renderer_1.RenderInternals.isServeUrl(file) ? null : 'bundling',
        'rendering',
    ].filter(truthy_1.truthy);
    const { cleanup: cleanupBundle, urlOrBundle } = await (0, setup_cache_1.bundleOnCliOrTakeServeUrl)({ fullPath: file, remotionRoot, steps, publicDir });
    (0, cleanup_before_quit_1.registerCleanupJob)(() => cleanupBundle());
    const puppeteerInstance = await browserInstance;
    const downloadMap = renderer_1.RenderInternals.makeDownloadMap();
    (0, cleanup_before_quit_1.registerCleanupJob)(() => renderer_1.RenderInternals.cleanDownloadMap(downloadMap));
    const comps = await (0, renderer_1.getCompositions)(urlOrBundle, {
        inputProps,
        puppeteerInstance,
        envVariables,
        timeoutInMilliseconds: puppeteerTimeout,
        chromiumOptions,
        port,
        browserExecutable,
        ffmpegExecutable,
        ffprobeExecutable,
        downloadMap,
    });
    const { compositionId, config, reason, argsAfterComposition } = await (0, get_composition_with_dimension_override_1.getCompositionWithDimensionOverride)({
        validCompositions: comps,
        height,
        width,
        args: remainingArgs,
    });
    const { format: imageFormat, source } = (0, determine_image_format_1.determineFinalImageFormat)({
        cliFlag: (_a = parse_command_line_1.parsedCli['image-format']) !== null && _a !== void 0 ? _a : null,
        configImageFormat: (_b = config_1.ConfigInternals.getUserPreferredImageFormat()) !== null && _b !== void 0 ? _b : null,
        downloadName: null,
        outName: (0, user_passed_output_location_1.getUserPassedOutputLocation)(argsAfterComposition),
        isLambda: false,
    });
    const relativeOutputLocation = (0, user_passed_output_location_1.getOutputLocation)({
        compositionId,
        defaultExtension: imageFormat,
        args: argsAfterComposition,
        type: 'asset',
    });
    const absoluteOutputLocation = (0, get_cli_options_1.getAndValidateAbsoluteOutputFile)(relativeOutputLocation, overwrite);
    (0, fs_1.mkdirSync)(path_1.default.join(absoluteOutputLocation, '..'), {
        recursive: true,
    });
    log_1.Log.info(chalk_1.chalk.gray(`Entry point = ${file} (${entryPointReason}), Output = ${relativeOutputLocation}, Format = ${imageFormat} (${source}), Composition = ${compositionId} (${reason})`));
    const renderProgress = (0, progress_bar_1.createOverwriteableCliOutput)((0, parse_command_line_1.quietFlagProvided)());
    const renderStart = Date.now();
    const downloads = [];
    let frames = 0;
    const totalFrames = 1;
    const updateProgress = () => {
        renderProgress.update((0, progress_bar_1.makeRenderingAndStitchingProgress)({
            rendering: {
                frames,
                concurrency: 1,
                doneIn: frames === totalFrames ? Date.now() - renderStart : null,
                steps,
                totalFrames,
            },
            downloads,
            stitching: null,
        }));
    };
    updateProgress();
    const onDownload = (src) => {
        const id = Math.random();
        const download = {
            id,
            name: src,
            progress: 0,
            downloaded: 0,
            totalBytes: null,
        };
        downloads.push(download);
        updateProgress();
        return ({ percent }) => {
            download.progress = percent;
            updateProgress();
        };
    };
    await (0, renderer_1.renderStill)({
        composition: config,
        frame: stillFrame,
        output: absoluteOutputLocation,
        serveUrl: urlOrBundle,
        quality,
        dumpBrowserLogs: renderer_1.RenderInternals.isEqualOrBelowLogLevel(config_1.ConfigInternals.Logging.getLogLevel(), 'verbose'),
        envVariables,
        imageFormat,
        inputProps,
        chromiumOptions,
        timeoutInMilliseconds: config_1.ConfigInternals.getCurrentPuppeteerTimeout(),
        scale,
        ffmpegExecutable,
        browserExecutable,
        overwrite,
        onDownload,
        port,
        downloadMap,
    });
    frames = 1;
    updateProgress();
    log_1.Log.info();
    const closeBrowserPromise = puppeteerInstance.close(false);
    log_1.Log.info(chalk_1.chalk.green('\nYour still frame is ready!'));
    const seconds = Math.round((Date.now() - startTime) / 1000);
    log_1.Log.info([
        '- Total render time:',
        seconds,
        seconds === 1 ? 'second' : 'seconds',
    ].join(' '));
    log_1.Log.info('-', 'Output can be found at:');
    log_1.Log.info(chalk_1.chalk.cyan(`▶️ ${absoluteOutputLocation}`));
    await closeBrowserPromise;
};
exports.still = still;
