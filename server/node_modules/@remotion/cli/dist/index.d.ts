import minimist from 'minimist';
export declare const cli: () => Promise<void>;
export { ConfigInternals, overrideRemotion } from './config/index';
export * from './render';
export declare const CliInternals: {
    createOverwriteableCliOutput: (quiet: boolean) => {
        update: (up: string) => boolean;
    };
    chalk: {
        enabled: boolean;
        visible: boolean;
        styles: Record<string, {
            codes: [number, number];
            name: string;
            wrap?: ((input: string, newline: boolean) => string) | undefined;
        }>;
        keys: Record<string, string[]>;
        alias?: ((name: string, col: string) => void) | undefined;
    } & {
        reset: (str: string) => string;
        bold: (str: string) => string;
        dim: (str: string) => string;
        italic: (str: string) => string;
        underline: (str: string) => string;
        inverse: (str: string) => string;
        hidden: (str: string) => string;
        strikethrough: (str: string) => string;
        black: (str: string) => string;
        red: (str: string) => string;
        green: (str: string) => string;
        yellow: (str: string) => string;
        blue: (str: string) => string;
        magenta: (str: string) => string;
        cyan: (str: string) => string;
        white: (str: string) => string;
        gray: (str: string) => string;
        bgBlack: (str: string) => string;
        bgRed: (str: string) => string;
        bgGreen: (str: string) => string;
        bgYellow: (str: string) => string;
        bgBlue: (str: string) => string;
        bgMagenta: (str: string) => string;
        bgCyan: (str: string) => string;
        bgWhite: (str: string) => string;
        blackBright: (str: string) => string;
        redBright: (str: string) => string;
        greenBright: (str: string) => string;
        yellowBright: (str: string) => string;
        blueBright: (str: string) => string;
        magentaBright: (str: string) => string;
        cyanBright: (str: string) => string;
        whiteBright: (str: string) => string;
        bgBlackBright: (str: string) => string;
        bgRedBright: (str: string) => string;
        bgGreenBright: (str: string) => string;
        bgYellowBright: (str: string) => string;
        bgBlueBright: (str: string) => string;
        bgMagentaBright: (str: string) => string;
        bgCyanBright: (str: string) => string;
        bgWhiteBright: (str: string) => string;
    };
    makeProgressBar: (percentage: number) => string;
    Log: {
        verbose: (message?: any, ...optionalParams: any[]) => void;
        info: (message?: any, ...optionalParams: any[]) => void;
        warn: (message?: any, ...optionalParams: any[]) => void;
        error: (message?: any, ...optionalParams: any[]) => void;
    };
    getCliOptions: (options: {
        isLambda: boolean;
        type: "still" | "series" | "get-compositions";
        remotionRoot: string;
    }) => Promise<{
        puppeteerTimeout: number;
        concurrency: string | number | null;
        frameRange: import("@remotion/renderer").FrameRange | null;
        shouldOutputImageSequence: boolean;
        inputProps: object;
        envVariables: Record<string, string>;
        quality: number | undefined;
        browser: import("@remotion/renderer").Browser;
        crf: import("@remotion/renderer").Crf | null;
        pixelFormat: "yuv420p" | "yuva420p" | "yuv422p" | "yuv444p" | "yuv420p10le" | "yuv422p10le" | "yuv444p10le" | "yuva444p10le";
        proResProfile: "4444-xq" | "4444" | "hq" | "standard" | "light" | "proxy" | undefined;
        everyNthFrame: number;
        numberOfGifLoops: import("./config/number-of-gif-loops").Loop;
        stillFrame: number;
        browserExecutable: import("@remotion/renderer").BrowserExecutable;
        ffmpegExecutable: import("@remotion/renderer").FfmpegExecutable;
        ffprobeExecutable: import("@remotion/renderer").FfmpegExecutable;
        logLevel: "verbose" | "info" | "warn" | "error";
        scale: number;
        chromiumOptions: import("@remotion/renderer").ChromiumOptions;
        overwrite: boolean;
        port: number | null;
        muted: boolean;
        enforceAudioTrack: boolean;
        publicDir: string | null;
        ffmpegOverride: import("@remotion/renderer").FfmpegOverrideFn;
        audioBitrate: string | null;
        videoBitrate: string | null;
        height: number | null;
        width: number | null;
    }>;
    loadConfig: (remotionRoot: string) => Promise<string | null>;
    initializeCli: (remotionRoot: string) => Promise<void>;
    BooleanFlags: string[];
    quietFlagProvided: () => boolean;
    parsedCli: import("./parse-command-line").CommandLineOptions & {
        _: string[];
    };
    handleCommonError: (err: Error) => Promise<void>;
    formatBytes: (number: number, options?: Intl.NumberFormatOptions & {
        locale: string;
        bits?: boolean | undefined;
        binary?: boolean | undefined;
        signed: boolean;
    }) => string;
    getFileSizeDownloadBar: (downloaded: number) => string;
    getFinalCodec: (options: {
        downloadName: string | null;
        outName: string | null;
    }) => {
        codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif";
        reason: string;
    };
    determineFinalImageFormat: ({ downloadName, outName, configImageFormat, cliFlag, isLambda, }: {
        downloadName: string | null;
        outName: string | null;
        configImageFormat: "png" | "jpeg" | "none" | null;
        cliFlag: "png" | "jpeg" | "none" | null;
        isLambda: boolean;
    }) => {
        format: import("@remotion/renderer").StillImageFormat;
        source: string;
    };
    minimist: typeof minimist;
    selectComposition: (validCompositions: import("remotion").TCompMetadata[]) => Promise<{
        compositionId: string;
        reason: string;
    }>;
    findEntryPoint: (args: string[], remotionRoot: string) => {
        file: string | null;
        remainingArgs: string[];
        reason: string;
    };
    getImageFormat: (codec: import("@remotion/renderer").CodecOrUndefined) => "png" | "jpeg" | "none";
    printCompositions: (compositions: import("remotion").TCompMetadata[]) => void;
    listOfRemotionPackages: string[];
};
