"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.benchmarkCommand = void 0;
const renderer_1 = require("@remotion/renderer");
const chalk_1 = require("./chalk");
const cleanup_before_quit_1 = require("./cleanup-before-quit");
const config_1 = require("./config");
const entry_point_1 = require("./entry-point");
const get_cli_options_1 = require("./get-cli-options");
const get_render_media_options_1 = require("./get-render-media-options");
const log_1 = require("./log");
const make_progress_bar_1 = require("./make-progress-bar");
const parse_command_line_1 = require("./parse-command-line");
const progress_bar_1 = require("./progress-bar");
const select_composition_1 = require("./select-composition");
const setup_cache_1 = require("./setup-cache");
const truthy_1 = require("./truthy");
const DEFAULT_RUNS = 3;
const getValidConcurrency = (renderMediaOptions) => {
    var _a;
    const concurrency = 'concurrency' in renderMediaOptions
        ? (_a = renderMediaOptions.concurrency) !== null && _a !== void 0 ? _a : null
        : null;
    const { concurrencies } = parse_command_line_1.parsedCli;
    if (!concurrencies) {
        return [renderer_1.RenderInternals.getActualConcurrency(concurrency)];
    }
    return concurrencies
        .split(',')
        .map((c) => parseInt(c.trim(), 10));
};
const runBenchmark = async (runs, options, onProgress) => {
    const timeTaken = [];
    for (let run = 0; run < runs; ++run) {
        const startTime = performance.now();
        await (0, renderer_1.renderMedia)({
            ...options,
            onProgress: ({ progress }) => onProgress === null || onProgress === void 0 ? void 0 : onProgress(run, progress),
        });
        const endTime = performance.now();
        timeTaken.push(endTime - startTime);
    }
    return timeTaken;
};
const formatTime = (time) => {
    let ret = '';
    const hours = Math.floor(time / (60 * 60 * 1000));
    if (hours) {
        ret = `${hours}h`;
    }
    time %= 60 * 60 * 1000;
    const minutes = Math.floor(time / (60 * 1000));
    if (minutes) {
        ret = `${ret}${minutes}m`;
    }
    time %= 60 * 1000;
    const seconds = (time / 1000).toFixed(5);
    if (seconds) {
        ret = `${ret}${seconds}s`;
    }
    return ret;
};
const avg = (time) => time.reduce((prev, curr) => prev + curr) / time.length;
const stdDev = (time) => {
    const mean = avg(time);
    return Math.sqrt(time.map((x) => (x - mean) ** 2).reduce((a, b) => a + b) / time.length);
};
const getResults = (results, runs) => {
    const mean = avg(results);
    const dev = stdDev(results);
    const max = Math.max(...results);
    const min = Math.min(...results);
    return `    Time (${chalk_1.chalk.green('mean')} ± ${chalk_1.chalk.green('σ')}):         ${chalk_1.chalk.green(formatTime(mean))} ± ${chalk_1.chalk.green(formatTime(dev))}\n    Range (${chalk_1.chalk.blue('min')} ... ${chalk_1.chalk.red('max')}):     ${chalk_1.chalk.blue(formatTime(min))} ... ${chalk_1.chalk.red(formatTime(max))} \t ${chalk_1.chalk.gray(`${runs} runs`)}
	`;
};
const makeBenchmarkProgressBar = ({ totalRuns, run, progress, doneIn, }) => {
    const totalProgress = (run + progress) / totalRuns;
    return [
        `Rendering (${run + 1} out of ${totalRuns} runs)`,
        (0, make_progress_bar_1.makeProgressBar)(totalProgress),
        doneIn === null
            ? `${(totalProgress * 100).toFixed(2)}% `
            : chalk_1.chalk.gray(doneIn),
    ].join(' ');
};
const benchmarkCommand = async (remotionRoot, args) => {
    var _a;
    const runs = (_a = parse_command_line_1.parsedCli.runs) !== null && _a !== void 0 ? _a : DEFAULT_RUNS;
    const { file, reason, remainingArgs } = (0, entry_point_1.findEntryPoint)(args, remotionRoot);
    if (!file) {
        log_1.Log.error('No entry file passed.');
        log_1.Log.info('Pass an additional argument specifying the entry file');
        log_1.Log.info();
        log_1.Log.info(`$ remotion benchmark <entry file>`);
        process.exit(1);
    }
    const { inputProps, envVariables, browserExecutable, ffmpegExecutable, ffprobeExecutable, chromiumOptions, port, puppeteerTimeout, browser, scale, publicDir, } = await (0, get_cli_options_1.getCliOptions)({
        isLambda: false,
        type: 'series',
        remotionRoot,
    });
    log_1.Log.verbose('Entry point:', file, 'reason:', reason);
    const browserInstance = (0, renderer_1.openBrowser)(browser, {
        browserExecutable,
        shouldDumpIo: renderer_1.RenderInternals.isEqualOrBelowLogLevel(config_1.ConfigInternals.Logging.getLogLevel(), 'verbose'),
        chromiumOptions,
        forceDeviceScaleFactor: scale,
    });
    const { urlOrBundle: bundleLocation, cleanup: cleanupBundle } = await (0, setup_cache_1.bundleOnCliOrTakeServeUrl)({
        fullPath: file,
        publicDir,
        remotionRoot,
        steps: ['bundling'],
    });
    (0, cleanup_before_quit_1.registerCleanupJob)(() => cleanupBundle());
    const puppeteerInstance = await browserInstance;
    const comps = await (0, renderer_1.getCompositions)(bundleLocation, {
        inputProps,
        envVariables,
        chromiumOptions,
        timeoutInMilliseconds: puppeteerTimeout,
        ffmpegExecutable,
        ffprobeExecutable,
        port,
        puppeteerInstance,
    });
    const ids = (remainingArgs[0]
        ? remainingArgs[0]
            .split(',')
            .map((c) => c.trim())
            .filter(truthy_1.truthy)
        : await (0, select_composition_1.selectCompositions)(comps));
    const compositions = ids.map((compId) => {
        const composition = comps.find((c) => c.id === compId);
        if (!composition) {
            throw new Error(`No composition with the ID "${compId}" found.`);
        }
        return composition;
    });
    if (compositions.length === 0) {
        log_1.Log.error('No composition IDs passed. Add another argument to the command specifying at least 1 composition ID.');
    }
    const benchmark = {};
    let count = 1;
    const { codec, reason: codecReason } = (0, get_cli_options_1.getFinalCodec)({
        downloadName: null,
        outName: null,
    });
    for (const composition of compositions) {
        const renderMediaOptions = await (0, get_render_media_options_1.getRenderMediaOptions)({
            config: composition,
            outputLocation: undefined,
            serveUrl: bundleLocation,
            codec,
            remotionRoot,
        });
        const concurrency = getValidConcurrency(renderMediaOptions);
        benchmark[composition.id] = {};
        for (const con of concurrency) {
            const benchmarkProgress = (0, progress_bar_1.createOverwriteableCliOutput)((0, parse_command_line_1.quietFlagProvided)());
            log_1.Log.info();
            log_1.Log.info(`${chalk_1.chalk.bold(`Benchmark #${count++}:`)} ${chalk_1.chalk.gray(`composition=${composition.id} concurrency=${con} codec=${codec} (${codecReason})`)}`);
            const timeTaken = await runBenchmark(runs, {
                ...renderMediaOptions,
                puppeteerInstance,
                concurrency: con,
            }, (run, progress) => {
                benchmarkProgress.update(makeBenchmarkProgressBar({
                    totalRuns: runs,
                    run,
                    doneIn: null,
                    progress,
                }));
            });
            benchmarkProgress.update('');
            benchmarkProgress.update(getResults(timeTaken, runs));
            benchmark[composition.id][`${con}`] = timeTaken;
        }
    }
    log_1.Log.info();
};
exports.benchmarkCommand = benchmarkCommand;
