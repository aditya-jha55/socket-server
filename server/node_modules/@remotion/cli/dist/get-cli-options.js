"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCliOptions = exports.getAndValidateAbsoluteOutputFile = exports.getFinalCodec = exports.validateFfmpegCanUseCodec = void 0;
const renderer_1 = require("@remotion/renderer");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const config_1 = require("./config");
const get_env_1 = require("./get-env");
const get_final_output_codec_1 = require("./get-final-output-codec");
const get_input_props_1 = require("./get-input-props");
const log_1 = require("./log");
const parse_command_line_1 = require("./parse-command-line");
const getAndValidateFrameRange = () => {
    const frameRange = config_1.ConfigInternals.getRange();
    if (typeof frameRange === 'number') {
        log_1.Log.warn('Selected a single frame. Assuming you want to output an image.');
        log_1.Log.warn(`If you want to render a video, pass a range:  '--frames=${frameRange}-${frameRange}'.`);
        log_1.Log.warn("To dismiss this message, add the '--sequence' flag explicitly.");
    }
    return frameRange;
};
const validateFfmpegCanUseCodec = async (codec, remotionRoot) => {
    const ffmpegExecutable = config_1.ConfigInternals.getCustomFfmpegExecutable();
    if (codec === 'vp8' &&
        !(await renderer_1.RenderInternals.ffmpegHasFeature({
            feature: 'enable-libvpx',
            ffmpegExecutable,
            remotionRoot,
        }))) {
        log_1.Log.error("The Vp8 codec has been selected, but your FFMPEG binary wasn't compiled with the --enable-lipvpx flag.");
        log_1.Log.error('This does not work, please switch out your FFMPEG binary or choose a different codec.');
    }
    if (codec === 'h265' &&
        !(await renderer_1.RenderInternals.ffmpegHasFeature({
            feature: 'enable-gpl',
            ffmpegExecutable,
            remotionRoot,
        }))) {
        log_1.Log.error("The H265 codec has been selected, but your FFMPEG binary wasn't compiled with the --enable-gpl flag.");
        log_1.Log.error('This does not work, please recompile your FFMPEG binary with --enable-gpl --enable-libx265 or choose a different codec.');
    }
    if (codec === 'h265' &&
        !(await renderer_1.RenderInternals.ffmpegHasFeature({
            feature: 'enable-libx265',
            ffmpegExecutable,
            remotionRoot,
        }))) {
        log_1.Log.error("The H265 codec has been selected, but your FFMPEG binary wasn't compiled with the --enable-libx265 flag.");
        log_1.Log.error('This does not work, please recompile your FFMPEG binary with --enable-gpl --enable-libx265 or choose a different codec.');
    }
};
exports.validateFfmpegCanUseCodec = validateFfmpegCanUseCodec;
const getFinalCodec = (options) => {
    var _a;
    const { codec, reason } = (0, get_final_output_codec_1.getFinalOutputCodec)({
        cliFlag: parse_command_line_1.parsedCli.codec,
        configFile: (_a = config_1.ConfigInternals.getOutputCodecOrUndefined()) !== null && _a !== void 0 ? _a : null,
        downloadName: options.downloadName,
        outName: options.outName,
    });
    return { codec, reason };
};
exports.getFinalCodec = getFinalCodec;
const getBrowser = () => { var _a; return (_a = config_1.ConfigInternals.getBrowser()) !== null && _a !== void 0 ? _a : renderer_1.RenderInternals.DEFAULT_BROWSER; };
const getAndValidateAbsoluteOutputFile = (relativeOutputLocation, overwrite) => {
    const absoluteOutputFile = path_1.default.resolve(process.cwd(), relativeOutputLocation);
    if (fs_1.default.existsSync(absoluteOutputFile) && !overwrite) {
        log_1.Log.error(`File at ${absoluteOutputFile} already exists. Use --overwrite to overwrite.`);
        process.exit(1);
    }
    return absoluteOutputFile;
};
exports.getAndValidateAbsoluteOutputFile = getAndValidateAbsoluteOutputFile;
const getAndValidateShouldOutputImageSequence = async ({ frameRange, isLambda, remotionRoot, }) => {
    const shouldOutputImageSequence = config_1.ConfigInternals.getShouldOutputImageSequence(frameRange);
    // When parsing options locally, we don't need FFMPEG because the render will happen on Lambda
    if (!shouldOutputImageSequence && !isLambda) {
        await renderer_1.RenderInternals.validateFfmpeg(config_1.ConfigInternals.getCustomFfmpegExecutable(), remotionRoot, 'ffmpeg');
    }
    return shouldOutputImageSequence;
};
const getCrf = (shouldOutputImageSequence) => {
    const crf = shouldOutputImageSequence
        ? null
        : config_1.ConfigInternals.getCrfOrUndefined();
    return crf;
};
const getProResProfile = () => {
    const proResProfile = config_1.ConfigInternals.getProResProfile();
    return proResProfile;
};
const getAndValidateBrowser = async (browserExecutable) => {
    const browser = getBrowser();
    try {
        await renderer_1.RenderInternals.ensureLocalBrowser(browser, browserExecutable);
    }
    catch (err) {
        log_1.Log.error('Could not download a browser for rendering frames.');
        log_1.Log.error(err);
        process.exit(1);
    }
    return browser;
};
const getCliOptions = async (options) => {
    var _a;
    const frameRange = getAndValidateFrameRange();
    const shouldOutputImageSequence = options.type === 'still'
        ? true
        : await getAndValidateShouldOutputImageSequence({
            frameRange,
            isLambda: options.isLambda,
            remotionRoot: options.remotionRoot,
        });
    const overwrite = config_1.ConfigInternals.getShouldOverwrite({
        defaultValue: !options.isLambda,
    });
    const crf = getCrf(shouldOutputImageSequence);
    const videoBitrate = config_1.ConfigInternals.getVideoBitrate();
    const pixelFormat = config_1.ConfigInternals.getPixelFormat();
    const proResProfile = getProResProfile();
    const browserExecutable = config_1.ConfigInternals.getBrowserExecutable();
    const ffmpegExecutable = config_1.ConfigInternals.getCustomFfmpegExecutable();
    const ffprobeExecutable = config_1.ConfigInternals.getCustomFfprobeExecutable();
    const scale = config_1.ConfigInternals.getScale();
    const port = config_1.ConfigInternals.getServerPort();
    const chromiumOptions = {
        disableWebSecurity: config_1.ConfigInternals.getChromiumDisableWebSecurity(),
        ignoreCertificateErrors: config_1.ConfigInternals.getIgnoreCertificateErrors(),
        headless: config_1.ConfigInternals.getChromiumHeadlessMode(),
        gl: (_a = config_1.ConfigInternals.getChromiumOpenGlRenderer()) !== null && _a !== void 0 ? _a : renderer_1.RenderInternals.DEFAULT_OPENGL_RENDERER,
    };
    const everyNthFrame = config_1.ConfigInternals.getEveryNthFrame();
    const numberOfGifLoops = config_1.ConfigInternals.getNumberOfGifLoops();
    const concurrency = config_1.ConfigInternals.getConcurrency();
    const height = config_1.ConfigInternals.getHeight();
    const width = config_1.ConfigInternals.getWidth();
    renderer_1.RenderInternals.validateConcurrency(concurrency, 'concurrency');
    return {
        puppeteerTimeout: config_1.ConfigInternals.getCurrentPuppeteerTimeout(),
        concurrency,
        frameRange,
        shouldOutputImageSequence,
        inputProps: (0, get_input_props_1.getInputProps)(() => undefined),
        envVariables: await (0, get_env_1.getEnvironmentVariables)(() => undefined),
        quality: config_1.ConfigInternals.getQuality(),
        browser: await getAndValidateBrowser(browserExecutable),
        crf,
        pixelFormat,
        proResProfile,
        everyNthFrame,
        numberOfGifLoops,
        stillFrame: config_1.ConfigInternals.getStillFrame(),
        browserExecutable,
        ffmpegExecutable,
        ffprobeExecutable,
        logLevel: config_1.ConfigInternals.Logging.getLogLevel(),
        scale,
        chromiumOptions,
        overwrite,
        port: port !== null && port !== void 0 ? port : null,
        muted: config_1.ConfigInternals.getMuted(),
        enforceAudioTrack: config_1.ConfigInternals.getEnforceAudioTrack(),
        publicDir: config_1.ConfigInternals.getPublicDir(),
        ffmpegOverride: config_1.ConfigInternals.getFfmpegOverrideFunction(),
        audioBitrate: config_1.ConfigInternals.getAudioBitrate(),
        videoBitrate,
        height,
        width,
    };
};
exports.getCliOptions = getCliOptions;
