"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadFile = void 0;
const fs_1 = require("fs");
const ensure_output_directory_1 = require("../ensure-output-directory");
const read_file_1 = require("./read-file");
const downloadFile = ({ onProgress, url, to: toFn, }) => {
    return new Promise((resolve, reject) => {
        let rejected = false;
        let resolved = false;
        let timeout;
        const resolveAndFlag = (val) => {
            resolved = true;
            resolve(val);
            if (timeout) {
                clearTimeout(timeout);
            }
        };
        const rejectAndFlag = (err) => {
            if (timeout) {
                clearTimeout(timeout);
            }
            reject(err);
            rejected = true;
        };
        const refreshTimeout = () => {
            if (timeout) {
                clearTimeout(timeout);
            }
            timeout = setTimeout(() => {
                if (resolved) {
                    return;
                }
                rejectAndFlag(new Error(`Tried to download file ${url}, but the server sent no data for 20 seconds`));
            }, 20000);
        };
        refreshTimeout();
        (0, read_file_1.readFile)(url)
            .then((res) => {
            var _a, _b;
            const contentDisposition = (_a = res.headers['content-disposition']) !== null && _a !== void 0 ? _a : null;
            const contentType = (_b = res.headers['content-type']) !== null && _b !== void 0 ? _b : null;
            const to = toFn(contentDisposition, contentType);
            (0, ensure_output_directory_1.ensureOutputDirectory)(to);
            const sizeHeader = res.headers['content-length'];
            const totalSize = typeof sizeHeader === 'undefined' ? null : Number(sizeHeader);
            const writeStream = (0, fs_1.createWriteStream)(to);
            let downloaded = 0;
            // Listen to 'close' event instead of more
            // concise method to avoid this problem
            // https://github.com/remotion-dev/remotion/issues/384#issuecomment-844398183
            writeStream.on('close', () => {
                if (rejected) {
                    return;
                }
                onProgress === null || onProgress === void 0 ? void 0 : onProgress({
                    downloaded,
                    percent: 1,
                    totalSize: downloaded,
                });
                refreshTimeout();
                return resolveAndFlag({ sizeInBytes: downloaded, to });
            });
            writeStream.on('error', (err) => rejectAndFlag(err));
            res.on('error', (err) => rejectAndFlag(err));
            res.pipe(writeStream).on('error', (err) => rejectAndFlag(err));
            res.on('data', (d) => {
                refreshTimeout();
                downloaded += d.length;
                refreshTimeout();
                onProgress === null || onProgress === void 0 ? void 0 : onProgress({
                    downloaded,
                    percent: totalSize === null ? null : downloaded / totalSize,
                    totalSize,
                });
            });
            res.on('close', () => {
                if (totalSize !== null && downloaded !== totalSize) {
                    rejectAndFlag(new Error(`Download finished with ${downloaded} bytes, but expected ${totalSize} bytes from 'Content-Length'.`));
                }
                writeStream.close();
            });
        })
            .catch((err) => {
            rejectAndFlag(err);
        });
    });
};
exports.downloadFile = downloadFile;
