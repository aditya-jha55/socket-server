"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVideoStreamDuration = exports.getVideoStreamDurationwithoutCache = exports.parseVideoStreamDuration = void 0;
const execa_1 = __importDefault(require("execa"));
const ffmpeg_flags_1 = require("../ffmpeg-flags");
const p_limit_1 = require("../p-limit");
const limit = (0, p_limit_1.pLimit)(1);
const parseAlternativeDuration = (stdout) => {
    const webmDuration = stdout.match(/TAG:DURATION=([0-9.]+):([0-9.]+):([0-9.]+)/);
    if (!webmDuration) {
        return null;
    }
    const [, hours, minutes, seconds] = webmDuration;
    const hoursAsNumber = Number(hours);
    if (Number.isNaN(hoursAsNumber)) {
        return null;
    }
    const minutesAsNumber = Number(minutes);
    if (Number.isNaN(minutesAsNumber)) {
        return null;
    }
    const secondsAsNumber = Number(seconds);
    if (Number.isNaN(secondsAsNumber)) {
        return null;
    }
    return secondsAsNumber + minutesAsNumber * 60 + hoursAsNumber * 3600;
};
const parseVideoStreamDuration = (stdout) => {
    const duration = stdout.match(/duration=([0-9.]+)/);
    const alternativeDuration = parseAlternativeDuration(stdout);
    const fps = stdout.match(/r_frame_rate=([0-9.]+)\/([0-9.]+)/);
    const result = {
        duration: duration ? parseFloat(duration[1]) : alternativeDuration,
        fps: fps ? parseInt(fps[1], 10) / parseInt(fps[2], 10) : null,
    };
    return result;
};
exports.parseVideoStreamDuration = parseVideoStreamDuration;
async function getVideoStreamDurationwithoutCache({ src, ffprobeExecutable, remotionRoot, }) {
    const args = [
        ['-v', 'error'],
        ['-select_streams', 'v:0'],
        ['-show_entries', 'stream'],
        [src],
    ]
        .reduce((acc, val) => acc.concat(val), [])
        .filter(Boolean);
    const task = await (0, execa_1.default)(await (0, ffmpeg_flags_1.getExecutableBinary)(ffprobeExecutable, remotionRoot, 'ffprobe'), args);
    const result = (0, exports.parseVideoStreamDuration)(task.stdout);
    return result;
}
exports.getVideoStreamDurationwithoutCache = getVideoStreamDurationwithoutCache;
async function getVideoStreamDurationUnlimited(downloadMap, src, ffprobeExecutable, remotionRoot) {
    if (downloadMap.videoDurationResultCache[src]) {
        return downloadMap.videoDurationResultCache[src];
    }
    const result = await getVideoStreamDurationwithoutCache({
        src,
        ffprobeExecutable,
        remotionRoot,
    });
    downloadMap.videoDurationResultCache[src] = result;
    return result;
}
const getVideoStreamDuration = (downloadMap, src, ffprobeExecutable, remotionRoot) => {
    return limit(() => getVideoStreamDurationUnlimited(downloadMap, src, ffprobeExecutable, remotionRoot));
};
exports.getVideoStreamDuration = getVideoStreamDuration;
