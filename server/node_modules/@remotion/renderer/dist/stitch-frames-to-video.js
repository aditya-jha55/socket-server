"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stitchFramesToVideo = exports.spawnFfmpeg = void 0;
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const remotion_1 = require("remotion");
const calculate_asset_positions_1 = require("./assets/calculate-asset-positions");
const convert_assets_to_file_urls_1 = require("./assets/convert-assets-to-file-urls");
const download_and_map_assets_to_file_1 = require("./assets/download-and-map-assets-to-file");
const audio_codec_1 = require("./audio-codec");
const codec_1 = require("./codec");
const codec_supports_media_1 = require("./codec-supports-media");
const convert_number_of_gif_loops_to_ffmpeg_1 = require("./convert-number-of-gif-loops-to-ffmpeg");
const crf_1 = require("./crf");
const delete_directory_1 = require("./delete-directory");
const does_have_m2_bug_1 = require("./does-have-m2-bug");
const ffmpeg_flags_1 = require("./ffmpeg-flags");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_codec_name_1 = require("./get-codec-name");
const get_extension_from_codec_1 = require("./get-extension-from-codec");
const get_prores_profile_name_1 = require("./get-prores-profile-name");
const make_cancel_signal_1 = require("./make-cancel-signal");
const merge_audio_track_1 = require("./merge-audio-track");
const parse_ffmpeg_progress_1 = require("./parse-ffmpeg-progress");
const pixel_format_1 = require("./pixel-format");
const preprocess_audio_track_1 = require("./preprocess-audio-track");
const prores_profile_1 = require("./prores-profile");
const truthy_1 = require("./truthy");
const validate_even_dimensions_with_codec_1 = require("./validate-even-dimensions-with-codec");
const validate_ffmpeg_1 = require("./validate-ffmpeg");
const validate_videobitrate_1 = require("./validate-videobitrate");
const packageJsonPath = path_1.default.join(__dirname, '..', 'package.json');
const packageJson = fs_1.default.existsSync(packageJsonPath)
    ? JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf-8'))
    : null;
const getAssetsData = async ({ assets, onDownload, fps, expectedFrames, verbose, ffmpegExecutable, ffprobeExecutable, onProgress, downloadMap, remotionRoot, }) => {
    const fileUrlAssets = await (0, convert_assets_to_file_urls_1.convertAssetsToFileUrls)({
        assets,
        onDownload: onDownload !== null && onDownload !== void 0 ? onDownload : (() => () => undefined),
        downloadMap,
    });
    (0, download_and_map_assets_to_file_1.markAllAssetsAsDownloaded)(downloadMap);
    const assetPositions = (0, calculate_asset_positions_1.calculateAssetPositions)(fileUrlAssets);
    if (verbose) {
        console.log('asset positions', assetPositions);
    }
    const preprocessProgress = new Array(assetPositions.length).fill(0);
    const updateProgress = () => {
        onProgress(preprocessProgress.reduce((a, b) => a + b, 0) / assetPositions.length);
    };
    const preprocessed = (await Promise.all(assetPositions.map(async (asset, index) => {
        const filterFile = path_1.default.join(downloadMap.audioMixing, `${index}.wav`);
        const result = await (0, preprocess_audio_track_1.preprocessAudioTrack)({
            ffmpegExecutable: ffmpegExecutable !== null && ffmpegExecutable !== void 0 ? ffmpegExecutable : null,
            ffprobeExecutable: ffprobeExecutable !== null && ffprobeExecutable !== void 0 ? ffprobeExecutable : null,
            outName: filterFile,
            asset,
            expectedFrames,
            fps,
            downloadMap,
            remotionRoot,
        });
        preprocessProgress[index] = 1;
        updateProgress();
        return result;
    }))).filter(truthy_1.truthy);
    const outName = path_1.default.join(downloadMap.audioPreprocessing, `audio.wav`);
    await (0, merge_audio_track_1.mergeAudioTrack)({
        ffmpegExecutable: ffmpegExecutable !== null && ffmpegExecutable !== void 0 ? ffmpegExecutable : null,
        files: preprocessed,
        outName,
        numberOfSeconds: Number((expectedFrames / fps).toFixed(3)),
        downloadMap,
        remotionRoot,
    });
    onProgress(1);
    (0, delete_directory_1.deleteDirectory)(downloadMap.audioMixing);
    preprocessed.forEach((p) => {
        (0, delete_directory_1.deleteDirectory)(p.outName);
    });
    return outName;
};
const spawnFfmpeg = async (options, remotionRoot) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    remotion_1.Internals.validateDimension(options.height, 'height', 'passed to `stitchFramesToVideo()`');
    remotion_1.Internals.validateDimension(options.width, 'width', 'passed to `stitchFramesToVideo()`');
    const codec = (_a = options.codec) !== null && _a !== void 0 ? _a : codec_1.DEFAULT_CODEC;
    (0, validate_even_dimensions_with_codec_1.validateEvenDimensionsWithCodec)({
        width: options.width,
        height: options.height,
        codec,
        scale: 1,
    });
    (0, prores_profile_1.validateSelectedCodecAndProResCombination)({
        codec,
        proResProfile: options.proResProfile,
    });
    (0, validate_videobitrate_1.validateBitrate)(options.audioBitrate, 'audioBitrate');
    (0, validate_videobitrate_1.validateBitrate)(options.videoBitrate, 'videoBitrate');
    remotion_1.Internals.validateFps(options.fps, 'in `stitchFramesToVideo()`', false);
    const pixelFormat = (_b = options.pixelFormat) !== null && _b !== void 0 ? _b : pixel_format_1.DEFAULT_PIXEL_FORMAT;
    await (0, validate_ffmpeg_1.validateFfmpeg)((_c = options.ffmpegExecutable) !== null && _c !== void 0 ? _c : null, remotionRoot, 'ffmpeg');
    const encoderName = (0, get_codec_name_1.getCodecName)(codec);
    const proResProfileName = (0, get_prores_profile_name_1.getProResProfileName)(codec, options.proResProfile);
    const mediaSupport = (0, codec_supports_media_1.codecSupportsMedia)(codec);
    const shouldRenderAudio = mediaSupport.audio &&
        (options.assetsInfo.assets.flat(1).length > 0 ||
            options.enforceAudioTrack) &&
        !options.muted;
    const shouldRenderVideo = mediaSupport.video;
    if (!shouldRenderAudio && !shouldRenderVideo) {
        throw new Error('The output format has neither audio nor video. This can happen if you are rendering an audio codec and the output file has no audio or the muted flag was passed.');
    }
    // Explanation: https://github.com/remotion-dev/remotion/issues/1647
    const resolvedAudioCodec = ((_d = options.internalOptions) === null || _d === void 0 ? void 0 : _d.preferLossless)
        ? (0, audio_codec_1.getDefaultAudioCodec)({ codec, preferLossless: true })
        : (_e = options.audioCodec) !== null && _e !== void 0 ? _e : (0, audio_codec_1.getDefaultAudioCodec)({ codec, preferLossless: false });
    const tempFile = options.outputLocation
        ? null
        : path_1.default.join(options.assetsInfo.downloadMap.stitchFrames, `out.${(0, get_extension_from_codec_1.getFileExtensionFromCodec)(codec, resolvedAudioCodec)}`);
    if (options.verbose) {
        console.log('[verbose] ffmpeg', (_f = options.ffmpegExecutable) !== null && _f !== void 0 ? _f : 'ffmpeg in PATH');
        console.log('[verbose] encoder', encoderName);
        console.log('[verbose] audioCodec', resolvedAudioCodec);
        console.log('[verbose] pixelFormat', pixelFormat);
        if (options.ffmpegOverride) {
            console.log('[verbose] ffmpegOverride', options.ffmpegOverride);
        }
        console.log('[verbose] codec', codec);
        console.log('[verbose] shouldRenderAudio', shouldRenderAudio);
        console.log('[verbose] shouldRenderVideo', shouldRenderVideo);
        console.log('[verbose] proResProfileName', proResProfileName);
    }
    (0, crf_1.validateQualitySettings)({
        crf: options.crf,
        codec,
        videoBitrate: options.videoBitrate,
    });
    (0, pixel_format_1.validateSelectedPixelFormatAndCodecCombination)(pixelFormat, codec);
    const expectedFrames = options.assetsInfo.assets.length;
    const updateProgress = (preStitchProgress, muxProgress) => {
        var _a;
        const totalFrameProgress = 0.5 * preStitchProgress * expectedFrames + muxProgress * 0.5;
        (_a = options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, Math.round(totalFrameProgress));
    };
    const audio = shouldRenderAudio
        ? await getAssetsData({
            assets: options.assetsInfo.assets,
            onDownload: options.onDownload,
            fps: options.fps,
            expectedFrames,
            verbose: (_g = options.verbose) !== null && _g !== void 0 ? _g : false,
            ffmpegExecutable: (_h = options.ffmpegExecutable) !== null && _h !== void 0 ? _h : null,
            ffprobeExecutable: (_j = options.ffprobeExecutable) !== null && _j !== void 0 ? _j : null,
            onProgress: (prog) => updateProgress(prog, 0),
            downloadMap: options.assetsInfo.downloadMap,
            remotionRoot,
        })
        : null;
    if (mediaSupport.audio && !mediaSupport.video) {
        if (!resolvedAudioCodec) {
            throw new TypeError('exporting audio but has no audio codec name. Report this in the Remotion repo.');
        }
        const ffmpegTask = (0, execa_1.default)(await (0, ffmpeg_flags_1.getExecutableBinary)((_k = options.ffmpegExecutable) !== null && _k !== void 0 ? _k : null, remotionRoot, 'ffmpeg'), [
            '-i',
            audio,
            '-c:a',
            (0, audio_codec_1.mapAudioCodecToFfmpegAudioCodecName)(resolvedAudioCodec),
            // Set bitrate up to 320k, for aac it might effectively be lower
            '-b:a',
            (_l = options.audioBitrate) !== null && _l !== void 0 ? _l : '320k',
            options.force ? '-y' : null,
            (_m = options.outputLocation) !== null && _m !== void 0 ? _m : tempFile,
        ].filter(remotion_1.Internals.truthy));
        (_o = options.cancelSignal) === null || _o === void 0 ? void 0 : _o.call(options, () => {
            ffmpegTask.kill();
        });
        await ffmpegTask;
        (_p = options.onProgress) === null || _p === void 0 ? void 0 : _p.call(options, expectedFrames);
        if (audio) {
            (0, delete_directory_1.deleteDirectory)(path_1.default.dirname(audio));
        }
        const file = await new Promise((resolve, reject) => {
            if (tempFile) {
                fs_1.promises
                    .readFile(tempFile)
                    .then((f) => {
                    return resolve(f);
                })
                    .catch((e) => reject(e));
            }
            else {
                resolve(null);
            }
        });
        (0, delete_directory_1.deleteDirectory)(options.assetsInfo.downloadMap.stitchFrames);
        return {
            getLogs: () => '',
            task: Promise.resolve(file),
        };
    }
    const ffmpegArgs = [
        ['-r', String(options.fps)],
        ...(((_q = options.internalOptions) === null || _q === void 0 ? void 0 : _q.preEncodedFileLocation)
            ? [['-i', (_r = options.internalOptions) === null || _r === void 0 ? void 0 : _r.preEncodedFileLocation]]
            : [
                ['-f', 'image2'],
                ['-s', `${options.width}x${options.height}`],
                ['-start_number', String(options.assetsInfo.firstFrameIndex)],
                ['-i', options.assetsInfo.imageSequenceName],
            ]),
        audio ? ['-i', audio] : null,
        ((_s = options.numberOfGifLoops) !== null && _s !== void 0 ? _s : null) === null
            ? null
            : [
                '-loop',
                (0, convert_number_of_gif_loops_to_ffmpeg_1.convertNumberOfGifLoopsToFfmpegSyntax)((_t = options.numberOfGifLoops) !== null && _t !== void 0 ? _t : null),
            ],
        // -c:v is the same as -vcodec as -codec:video
        // and specified the video codec.
        ['-c:v', encoderName],
        ...(((_u = options.internalOptions) === null || _u === void 0 ? void 0 : _u.preEncodedFileLocation)
            ? []
            : [
                proResProfileName ? ['-profile:v', proResProfileName] : null,
                ['-pix_fmt', pixelFormat],
                // Without explicitly disabling auto-alt-ref,
                // transparent WebM generation doesn't work
                pixelFormat === 'yuva420p' ? ['-auto-alt-ref', '0'] : null,
                ...(0, crf_1.validateQualitySettings)({
                    crf: options.crf,
                    videoBitrate: options.videoBitrate,
                    codec,
                }),
            ]),
        codec === 'h264' ? ['-movflags', 'faststart'] : null,
        resolvedAudioCodec
            ? ['-c:a', (0, audio_codec_1.mapAudioCodecToFfmpegAudioCodecName)(resolvedAudioCodec)]
            : null,
        // Set max bitrate up to 1024kbps, will choose lower if that's too much
        resolvedAudioCodec ? ['-b:a', options.audioBitrate || '512K'] : null,
        // Ignore metadata that may come from remote media
        ['-map_metadata', '-1'],
        [
            '-metadata',
            `comment=` +
                [`Made with Remotion`, packageJson ? packageJson.version : null].join(' '),
        ],
        options.force ? '-y' : null,
        (_v = options.outputLocation) !== null && _v !== void 0 ? _v : tempFile,
    ];
    if (options.verbose) {
        console.log('Generated FFMPEG command:');
        console.log(ffmpegArgs);
    }
    const ffmpegString = ffmpegArgs.flat(2).filter(Boolean);
    const finalFfmpegString = options.ffmpegOverride
        ? options.ffmpegOverride({ type: 'stitcher', args: ffmpegString })
        : ffmpegString;
    if (options.verbose && options.ffmpegOverride) {
        console.log('Generated final FFMPEG command:');
        console.log(finalFfmpegString);
    }
    const task = (0, execa_1.default)(await (0, ffmpeg_flags_1.getExecutableBinary)((_w = options.ffmpegExecutable) !== null && _w !== void 0 ? _w : null, remotionRoot, 'ffmpeg'), finalFfmpegString, {
        cwd: options.dir,
    });
    (_x = options.cancelSignal) === null || _x === void 0 ? void 0 : _x.call(options, () => {
        task.kill();
    });
    let ffmpegOutput = '';
    let isFinished = false;
    (_y = task.stderr) === null || _y === void 0 ? void 0 : _y.on('data', (data) => {
        var _a;
        const str = data.toString();
        ffmpegOutput += str;
        if (options.onProgress) {
            const parsed = (0, parse_ffmpeg_progress_1.parseFfmpegProgress)(str);
            // FFMPEG bug: In some cases, FFMPEG does hang after it is finished with it's job
            // Example repo: https://github.com/JonnyBurger/ffmpeg-repro (access can be given upon request)
            if (parsed !== undefined) {
                // If two times in a row the finishing frame is logged, we quit the render
                if (parsed === expectedFrames) {
                    if (isFinished) {
                        (_a = task.stdin) === null || _a === void 0 ? void 0 : _a.write('q');
                    }
                    else {
                        isFinished = true;
                    }
                }
                updateProgress(1, parsed);
            }
        }
    });
    return {
        task: task.then(() => {
            (0, delete_directory_1.deleteDirectory)(options.assetsInfo.downloadMap.audioPreprocessing);
            if (tempFile === null) {
                (0, delete_directory_1.deleteDirectory)(options.assetsInfo.downloadMap.stitchFrames);
                return null;
            }
            return fs_1.promises
                .readFile(tempFile)
                .then((file) => {
                return Promise.all([
                    file,
                    (0, delete_directory_1.deleteDirectory)(path_1.default.dirname(tempFile)),
                    (0, delete_directory_1.deleteDirectory)(options.assetsInfo.downloadMap.stitchFrames),
                ]);
            })
                .then(([file]) => file);
        }),
        getLogs: () => ffmpegOutput,
    };
};
exports.spawnFfmpeg = spawnFfmpeg;
/**
 * @description Takes a series of images and audio information generated by renderFrames() and encodes it to a video.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/stitch-frames-to-video)
 */
const stitchFramesToVideo = async (options) => {
    var _a, _b;
    const remotionRoot = (0, find_closest_package_json_1.findRemotionRoot)();
    const { task, getLogs } = await (0, exports.spawnFfmpeg)(options, remotionRoot);
    const happyPath = task.catch(() => {
        throw new Error(getLogs());
    });
    (0, does_have_m2_bug_1.warnAboutM2Bug)((_a = options.codec) !== null && _a !== void 0 ? _a : null, (_b = options.pixelFormat) !== null && _b !== void 0 ? _b : null);
    return Promise.race([
        happyPath,
        new Promise((_resolve, reject) => {
            var _a;
            (_a = options.cancelSignal) === null || _a === void 0 ? void 0 : _a.call(options, () => {
                reject(new Error(make_cancel_signal_1.cancelErrorMessages.stitchFramesToVideo));
            });
        }),
    ]);
};
exports.stitchFramesToVideo = stitchFramesToVideo;
