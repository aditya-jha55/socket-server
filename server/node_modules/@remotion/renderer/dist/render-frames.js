"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderFrames = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const perf_hooks_1 = require("perf_hooks");
const remotion_1 = require("remotion");
const download_and_map_assets_to_file_1 = require("./assets/download-and-map-assets-to-file");
const download_map_1 = require("./assets/download-map");
const browser_1 = require("./browser");
const compress_assets_1 = require("./compress-assets");
const cycle_browser_tabs_1 = require("./cycle-browser-tabs");
const handle_javascript_exception_1 = require("./error-handling/handle-javascript-exception");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_concurrency_1 = require("./get-concurrency");
const get_duration_from_frame_range_1 = require("./get-duration-from-frame-range");
const get_frame_padded_index_1 = require("./get-frame-padded-index");
const get_frame_to_render_1 = require("./get-frame-to-render");
const image_format_1 = require("./image-format");
const legacy_webpack_config_1 = require("./legacy-webpack-config");
const make_cancel_signal_1 = require("./make-cancel-signal");
const open_browser_1 = require("./open-browser");
const perf_1 = require("./perf");
const pool_1 = require("./pool");
const prepare_server_1 = require("./prepare-server");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const quality_1 = require("./quality");
const replace_browser_1 = require("./replace-browser");
const seek_to_frame_1 = require("./seek-to-frame");
const set_props_and_env_1 = require("./set-props-and-env");
const take_frame_and_compose_1 = require("./take-frame-and-compose");
const truthy_1 = require("./truthy");
const validate_scale_1 = require("./validate-scale");
const MAX_RETRIES_PER_FRAME = 1;
const getComposition = (others) => {
    if ('composition' in others) {
        return others.composition;
    }
    if ('config' in others) {
        return others.config;
    }
    return undefined;
};
const getConcurrency = (others) => {
    if ('concurrency' in others) {
        return others.concurrency;
    }
    if ('parallelism' in others) {
        return others.parallelism;
    }
    return undefined;
};
const innerRenderFrames = ({ onFrameUpdate, outputDir, onStart, inputProps, quality, imageFormat = image_format_1.DEFAULT_IMAGE_FORMAT, frameRange, onError, envVariables, onBrowserLog, onFrameBuffer, onDownload, pagesArray, serveUrl, composition, timeoutInMilliseconds, scale = 1, actualConcurrency, everyNthFrame = 1, proxyPort, cancelSignal, downloadMap, muted, makeBrowser, browserReplacer, }) => {
    if (outputDir) {
        if (!fs_1.default.existsSync(outputDir)) {
            fs_1.default.mkdirSync(outputDir, {
                recursive: true,
            });
        }
    }
    const downloadPromises = [];
    const realFrameRange = (0, get_frame_to_render_1.getRealFrameRange)(composition.durationInFrames, frameRange !== null && frameRange !== void 0 ? frameRange : null);
    const framesToRender = (0, get_duration_from_frame_range_1.getFramesToRender)(realFrameRange, everyNthFrame);
    const lastFrame = framesToRender[framesToRender.length - 1];
    const makePage = async () => {
        const page = await browserReplacer.getBrowser().newPage();
        pagesArray.push(page);
        await page.setViewport({
            width: composition.width,
            height: composition.height,
            deviceScaleFactor: scale !== null && scale !== void 0 ? scale : 1,
        });
        const logCallback = (log) => {
            onBrowserLog === null || onBrowserLog === void 0 ? void 0 : onBrowserLog({
                stackTrace: log.stackTrace(),
                text: log.text,
                type: log.type,
            });
        };
        if (onBrowserLog) {
            page.on('console', logCallback);
        }
        const initialFrame = realFrameRange[0];
        await (0, set_props_and_env_1.setPropsAndEnv)({
            inputProps,
            envVariables,
            page,
            serveUrl,
            initialFrame,
            timeoutInMilliseconds,
            proxyPort,
            retriesRemaining: 2,
            audioEnabled: !muted,
            videoEnabled: imageFormat !== 'none',
        });
        await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
            // eslint-disable-next-line max-params
            pageFunction: (id, defaultProps, durationInFrames, fps, height, width) => {
                window.setBundleMode({
                    type: 'composition',
                    compositionName: id,
                    compositionDefaultProps: defaultProps,
                    compositionDurationInFrames: durationInFrames,
                    compositionFps: fps,
                    compositionHeight: height,
                    compositionWidth: width,
                });
            },
            args: [
                composition.id,
                composition.defaultProps,
                composition.durationInFrames,
                composition.fps,
                composition.height,
                composition.width,
            ],
            frame: null,
            page,
        });
        page.off('console', logCallback);
        return page;
    };
    const getPool = async () => {
        const pages = new Array(actualConcurrency).fill(true).map(() => makePage());
        const puppeteerPages = await Promise.all(pages);
        const pool = new pool_1.Pool(puppeteerPages);
        return pool;
    };
    // If rendering a GIF and skipping frames, we must ensure it starts from 0
    // and then is consecutive so FFMPEG recognizes the sequence
    const countType = everyNthFrame === 1 ? 'actual-frames' : 'from-zero';
    const filePadLength = (0, get_frame_padded_index_1.getFilePadLength)({
        lastFrame,
        totalFrames: framesToRender.length,
        countType,
    });
    let framesRendered = 0;
    const poolPromise = getPool();
    onStart({
        frameCount: framesToRender.length,
    });
    const assets = new Array(framesToRender.length).fill(undefined);
    let stopped = false;
    cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
        stopped = true;
    });
    const renderFrameWithOptionToReject = async ({ frame, index, reject, width, height, }) => {
        const pool = await poolPromise;
        const freePage = await pool.acquire();
        if (stopped) {
            return reject(new Error('Render was stopped'));
        }
        const startTime = perf_hooks_1.performance.now();
        const errorCallbackOnFrame = (err) => {
            reject(err);
        };
        const cleanupPageError = (0, handle_javascript_exception_1.handleJavascriptException)({
            page: freePage,
            onError: errorCallbackOnFrame,
            frame,
        });
        freePage.on('error', errorCallbackOnFrame);
        await (0, seek_to_frame_1.seekToFrame)({ frame, page: freePage });
        if (!outputDir && !onFrameBuffer && imageFormat !== 'none') {
            throw new Error('Called renderFrames() without specifying either `outputDir` or `onFrameBuffer`');
        }
        if (outputDir && onFrameBuffer && imageFormat !== 'none') {
            throw new Error('Pass either `outputDir` or `onFrameBuffer` to renderFrames(), not both.');
        }
        const id = (0, perf_1.startPerfMeasure)('save');
        const frameDir = outputDir !== null && outputDir !== void 0 ? outputDir : downloadMap.compositingDir;
        const { buffer, collectedAssets } = await (0, take_frame_and_compose_1.takeFrameAndCompose)({
            frame,
            freePage,
            height,
            imageFormat,
            output: path_1.default.join(frameDir, (0, get_frame_padded_index_1.getFrameOutputFileName)({
                frame,
                imageFormat,
                index,
                countType,
                lastFrame,
                totalFrames: framesToRender.length,
            })),
            quality,
            width,
            scale,
            downloadMap,
            wantsBuffer: Boolean(onFrameBuffer),
        });
        if (onFrameBuffer) {
            if (!buffer) {
                throw new Error('unexpected null buffer');
            }
            onFrameBuffer(buffer, frame);
        }
        (0, perf_1.stopPerfMeasure)(id);
        const compressedAssets = collectedAssets.map((asset) => (0, compress_assets_1.compressAsset)(assets.filter(truthy_1.truthy).flat(1), asset));
        assets[index] = compressedAssets;
        compressedAssets.forEach((asset) => {
            (0, download_and_map_assets_to_file_1.downloadAndMapAssetsToFileUrl)({
                asset,
                onDownload,
                downloadMap,
            }).catch((err) => {
                onError(new Error(`Error while downloading asset: ${err.stack}`));
            });
        });
        framesRendered++;
        onFrameUpdate(framesRendered, frame, perf_hooks_1.performance.now() - startTime);
        cleanupPageError();
        freePage.off('error', errorCallbackOnFrame);
        pool.release(freePage);
    };
    const renderFrame = (frame, index) => {
        return new Promise((resolve, reject) => {
            renderFrameWithOptionToReject({
                frame,
                index,
                reject,
                width: composition.width,
                height: composition.height,
            })
                .then(() => {
                resolve();
            })
                .catch((err) => {
                reject(err);
            });
        });
    };
    const renderFrameAndRetryTargetClose = async (frame, index, retriesLeft, attempt) => {
        var _a, _b;
        try {
            await renderFrame(frame, index);
        }
        catch (err) {
            if (!((_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.includes('Target closed')) &&
                !((_b = err === null || err === void 0 ? void 0 : err.message) === null || _b === void 0 ? void 0 : _b.includes('Session closed'))) {
                throw err;
            }
            if ((0, make_cancel_signal_1.isUserCancelledRender)(err)) {
                throw err;
            }
            if (stopped) {
                return;
            }
            if (retriesLeft === 0) {
                console.warn(`The browser crashed ${attempt} times while rendering frame ${frame}. Not retrying anymore. Learn more about this error under https://www.remotion.dev/docs/target-closed`);
                throw err;
            }
            console.warn(`The browser crashed while rendering frame ${frame}, retrying ${retriesLeft} more times. Learn more about this error under https://www.remotion.dev/docs/target-closed`);
            await browserReplacer.replaceBrowser(makeBrowser, async () => {
                const pages = new Array(actualConcurrency)
                    .fill(true)
                    .map(() => makePage());
                const puppeteerPages = await Promise.all(pages);
                const pool = await poolPromise;
                for (const newPage of puppeteerPages) {
                    pool.release(newPage);
                }
            });
            await renderFrameAndRetryTargetClose(frame, index, retriesLeft - 1, attempt + 1);
        }
    };
    const progress = Promise.all(framesToRender.map((frame, index) => renderFrameAndRetryTargetClose(frame, index, MAX_RETRIES_PER_FRAME, 1)));
    const happyPath = progress.then(() => {
        const firstFrameIndex = countType === 'from-zero' ? 0 : framesToRender[0];
        const returnValue = {
            assetsInfo: {
                assets,
                imageSequenceName: `element-%0${filePadLength}d.${imageFormat}`,
                firstFrameIndex,
                downloadMap,
            },
            frameCount: framesToRender.length,
        };
        return returnValue;
    });
    return happyPath
        .then(() => {
        return Promise.all(downloadPromises);
    })
        .then(() => happyPath);
};
/**
 * @description Renders a series of images using Puppeteer and computes information for mixing audio.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/render-frames)
 */
const renderFrames = (options) => {
    var _a, _b, _c;
    const composition = getComposition(options);
    const concurrency = getConcurrency(options);
    if (!composition) {
        throw new Error('No `composition` option has been specified for renderFrames()');
    }
    remotion_1.Internals.validateDimension(composition.height, 'height', 'in the `config` object passed to `renderFrames()`');
    remotion_1.Internals.validateDimension(composition.width, 'width', 'in the `config` object passed to `renderFrames()`');
    remotion_1.Internals.validateFps(composition.fps, 'in the `config` object of `renderFrames()`', false);
    remotion_1.Internals.validateDurationInFrames({
        durationInFrames: composition.durationInFrames,
        component: 'in the `config` object passed to `renderFrames()`',
        allowFloats: false,
    });
    if (options.quality !== undefined && options.imageFormat !== 'jpeg') {
        throw new Error("You can only pass the `quality` option if `imageFormat` is 'jpeg'.");
    }
    const selectedServeUrl = (0, legacy_webpack_config_1.getServeUrlWithFallback)(options);
    (0, quality_1.validateQuality)(options.quality);
    (0, validate_scale_1.validateScale)(options.scale);
    const makeBrowser = () => {
        var _a;
        return (0, open_browser_1.openBrowser)(browser_1.DEFAULT_BROWSER, {
            shouldDumpIo: options.dumpBrowserLogs,
            browserExecutable: options.browserExecutable,
            chromiumOptions: options.chromiumOptions,
            forceDeviceScaleFactor: (_a = options.scale) !== null && _a !== void 0 ? _a : 1,
        });
    };
    const browserInstance = (_a = options.puppeteerInstance) !== null && _a !== void 0 ? _a : makeBrowser();
    const downloadMap = (_b = options.downloadMap) !== null && _b !== void 0 ? _b : (0, download_map_1.makeDownloadMap)();
    const onDownload = (_c = options.onDownload) !== null && _c !== void 0 ? _c : (() => () => undefined);
    const actualConcurrency = (0, get_concurrency_1.getActualConcurrency)(concurrency !== null && concurrency !== void 0 ? concurrency : null);
    const openedPages = [];
    return new Promise((resolve, reject) => {
        var _a, _b, _c;
        const cleanup = [];
        if (!options.downloadMap) {
            cleanup.push(() => (0, download_map_1.cleanDownloadMap)(downloadMap));
        }
        const onError = (err) => {
            reject(err);
        };
        Promise.race([
            new Promise((_, rej) => {
                var _a;
                (_a = options.cancelSignal) === null || _a === void 0 ? void 0 : _a.call(options, () => {
                    rej(new Error(make_cancel_signal_1.cancelErrorMessages.renderFrames));
                });
            }),
            Promise.all([
                (0, prepare_server_1.prepareServer)({
                    webpackConfigOrServeUrl: selectedServeUrl,
                    onDownload,
                    onError,
                    ffmpegExecutable: (_a = options.ffmpegExecutable) !== null && _a !== void 0 ? _a : null,
                    ffprobeExecutable: (_b = options.ffprobeExecutable) !== null && _b !== void 0 ? _b : null,
                    port: (_c = options.port) !== null && _c !== void 0 ? _c : null,
                    downloadMap,
                    remotionRoot: (0, find_closest_package_json_1.findRemotionRoot)(),
                }),
                browserInstance,
            ]).then(([{ serveUrl, closeServer, offthreadPort }, puppeteerInstance]) => {
                const browserReplacer = (0, replace_browser_1.handleBrowserCrash)(puppeteerInstance);
                const { stopCycling } = (0, cycle_browser_tabs_1.cycleBrowserTabs)(browserReplacer, actualConcurrency);
                cleanup.push(stopCycling);
                cleanup.push(() => closeServer(false));
                return innerRenderFrames({
                    ...options,
                    puppeteerInstance,
                    onError,
                    pagesArray: openedPages,
                    serveUrl,
                    composition,
                    actualConcurrency,
                    onDownload,
                    proxyPort: offthreadPort,
                    downloadMap,
                    makeBrowser,
                    browserReplacer,
                });
            }),
        ])
            .then((res) => {
            return resolve(res);
        })
            .catch((err) => reject(err))
            .finally(() => {
            // If browser instance was passed in, we close all the pages
            // we opened.
            // If new browser was opened, then closing the browser as a cleanup.
            if (options.puppeteerInstance) {
                Promise.all(openedPages.map((p) => p.close())).catch((err) => {
                    if (!(err === null || err === void 0 ? void 0 : err.message.includes('Target closed'))) {
                        console.log('Unable to close browser tab', err);
                    }
                });
            }
            else {
                Promise.resolve(browserInstance)
                    .then((puppeteerInstance) => {
                    return puppeteerInstance.close(true);
                })
                    .catch((err) => {
                    if (!(err === null || err === void 0 ? void 0 : err.message.includes('Target closed'))) {
                        console.log('Unable to close browser', err);
                    }
                });
            }
            cleanup.forEach((c) => {
                c();
            });
            // Don't clear download dir because it might be used by stitchFramesToVideo
        });
    });
};
exports.renderFrames = renderFrames;
