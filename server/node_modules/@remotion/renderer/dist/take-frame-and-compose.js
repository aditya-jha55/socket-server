"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.takeFrameAndCompose = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const compose_1 = require("./compositor/compose");
const provide_screenshot_1 = require("./provide-screenshot");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const truthy_1 = require("./truthy");
const takeFrameAndCompose = async ({ freePage, imageFormat, quality, frame, width, height, output, scale, downloadMap, wantsBuffer, }) => {
    var _a;
    const [clipRegion, collectedAssets] = await Promise.all([
        (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
            pageFunction: () => {
                if (typeof window.remotion_getClipRegion === 'undefined') {
                    return null;
                }
                return window.remotion_getClipRegion();
            },
            args: [],
            frame,
            page: freePage,
        }),
        (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
            pageFunction: () => {
                return window.remotion_collectAssets();
            },
            args: [],
            frame,
            page: freePage,
        }),
    ]);
    if (imageFormat === 'none') {
        return { buffer: null, collectedAssets };
    }
    const needsComposing = clipRegion === null
        ? null
        : {
            tmpFile: path_1.default.join(downloadMap.compositingDir, `${frame}.${imageFormat}`),
            finalOutfie: output !== null && output !== void 0 ? output : path_1.default.join(downloadMap.compositingDir, `${frame}-final.${imageFormat}`),
            clipRegion: clipRegion,
        };
    if (clipRegion !== 'hide') {
        const shouldMakeBuffer = wantsBuffer && !needsComposing;
        const buf = await (0, provide_screenshot_1.provideScreenshot)({
            page: freePage,
            imageFormat,
            quality,
            options: {
                frame,
                output: shouldMakeBuffer ? null : (_a = needsComposing === null || needsComposing === void 0 ? void 0 : needsComposing.tmpFile) !== null && _a !== void 0 ? _a : output,
            },
            height,
            width,
            clipRegion,
        });
        if (shouldMakeBuffer) {
            return { buffer: buf, collectedAssets };
        }
    }
    if (needsComposing) {
        await (0, compose_1.compose)({
            height: height * scale,
            width: width * scale,
            layers: [
                needsComposing.clipRegion === 'hide'
                    ? null
                    : {
                        type: imageFormat === 'jpeg'
                            ? 'JpgImage'
                            : 'PngImage',
                        params: {
                            height: needsComposing.clipRegion.height * scale,
                            width: needsComposing.clipRegion.width * scale,
                            src: needsComposing.tmpFile,
                            x: needsComposing.clipRegion.x * scale,
                            y: needsComposing.clipRegion.y * scale,
                        },
                    },
            ].filter(truthy_1.truthy),
            output: needsComposing.finalOutfie,
            downloadMap,
            imageFormat: imageFormat === 'jpeg' ? 'Jpeg' : 'Png',
        });
        if (wantsBuffer) {
            const buffer = await fs_1.default.promises.readFile(needsComposing.finalOutfie);
            await fs_1.default.promises.unlink(needsComposing.finalOutfie);
            return { buffer, collectedAssets };
        }
    }
    return { buffer: null, collectedAssets };
};
exports.takeFrameAndCompose = takeFrameAndCompose;
