/// <reference types="node" />
import type { RenderMediaOnDownload } from './assets/download-and-map-assets-to-file';
import type { RenderAssetInfo } from './assets/download-map';
import type { AudioCodec } from './audio-codec';
import type { Codec } from './codec';
import type { FfmpegExecutable } from './ffmpeg-executable';
import type { FfmpegOverrideFn } from './ffmpeg-override';
import type { ImageFormat } from './image-format';
import type { CancelSignal } from './make-cancel-signal';
import type { PixelFormat } from './pixel-format';
import type { ProResProfile } from './prores-profile';
export declare type StitcherOptions = {
    audioBitrate?: string | null;
    videoBitrate?: string | null;
    fps: number;
    width: number;
    height: number;
    outputLocation?: string | null;
    force: boolean;
    assetsInfo: RenderAssetInfo;
    pixelFormat?: PixelFormat;
    numberOfGifLoops?: number | null;
    codec?: Codec;
    audioCodec?: AudioCodec | null;
    crf?: number | null;
    onProgress?: (progress: number) => void;
    onDownload?: RenderMediaOnDownload;
    proResProfile?: ProResProfile;
    verbose?: boolean;
    ffmpegExecutable?: FfmpegExecutable;
    ffprobeExecutable?: FfmpegExecutable;
    dir?: string;
    cancelSignal?: CancelSignal;
    internalOptions?: {
        preEncodedFileLocation: string | null;
        imageFormat: ImageFormat;
        preferLossless: boolean;
    };
    muted?: boolean;
    enforceAudioTrack?: boolean;
    ffmpegOverride?: FfmpegOverrideFn;
};
declare type ReturnType = {
    task: Promise<Buffer | null>;
    getLogs: () => string;
};
export declare const spawnFfmpeg: (options: StitcherOptions, remotionRoot: string) => Promise<ReturnType>;
/**
 * @description Takes a series of images and audio information generated by renderFrames() and encodes it to a video.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/stitch-frames-to-video)
 */
export declare const stitchFramesToVideo: (options: StitcherOptions) => Promise<Buffer | null>;
export {};
