"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compose = void 0;
const child_process_1 = require("child_process");
const crypto_1 = require("crypto");
const promises_1 = require("fs/promises");
const get_executable_path_1 = require("./get-executable-path");
const getCompositorHash = ({ ...input }) => {
    return (0, crypto_1.createHash)('sha256').update(JSON.stringify(input)).digest('base64');
};
const compose = async ({ height, width, layers, output, downloadMap, imageFormat, }) => {
    const bin = (0, get_executable_path_1.getExecutablePath)();
    const hash = getCompositorHash({ height, width, layers, imageFormat });
    if (downloadMap.compositorCache[hash]) {
        await (0, promises_1.copyFile)(downloadMap.compositorCache[hash], output);
        return;
    }
    const payload = {
        v: 1,
        height,
        width,
        layers,
        output,
        output_format: imageFormat,
    };
    await new Promise((resolve, reject) => {
        const child = (0, child_process_1.spawn)(bin);
        child.stdin.write(JSON.stringify(payload));
        child.stdin.end();
        const stderrChunks = [];
        child.stderr.on('data', (d) => stderrChunks.push(d));
        child.on('close', (code) => {
            if (code === 0) {
                resolve();
            }
            else {
                const message = Buffer.concat(stderrChunks).toString('utf-8');
                const parsed = JSON.parse(message);
                const err = new Error(parsed.error);
                err.stack = parsed.error + '\n' + parsed.backtrace;
                reject(err);
            }
        });
    });
    downloadMap.compositorCache[hash] = output;
};
exports.compose = compose;
