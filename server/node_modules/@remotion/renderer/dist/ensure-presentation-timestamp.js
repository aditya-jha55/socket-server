"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensurePresentationTimestamps = exports.ensurePresentationTimestampWithoutCache = void 0;
const execa_1 = __importDefault(require("execa"));
const path_1 = __importDefault(require("path"));
const ffmpeg_flags_1 = require("./ffmpeg-flags");
const guess_extension_for_media_1 = require("./guess-extension-for-media");
const truthy_1 = require("./truthy");
let callbacks = [];
const getTemporaryOutputName = async ({ src, remotionRoot, ffprobeBinary, }) => {
    const parts = src.split(path_1.default.sep);
    // If there is no file extension for the video, then we need to temporarily add an extension
    const lastPart = parts[parts.length - 1];
    const extraExtension = lastPart.includes('.')
        ? null
        : await (0, guess_extension_for_media_1.guessExtensionForVideo)({
            src,
            remotionRoot,
            ffprobeBinary,
        });
    return parts
        .map((p, i) => {
        if (i === parts.length - 1) {
            return [`pts-${p}`, extraExtension].filter(truthy_1.truthy).join('.');
        }
        return p;
    })
        .join(path_1.default.sep);
};
const ensurePresentationTimestampWithoutCache = async ({ src, remotionRoot, ffmpegExecutable, ffprobeExecutable, }) => {
    // If there is no file extension for the video, then we need to tempoa
    const output = await getTemporaryOutputName({
        src,
        remotionRoot,
        ffprobeBinary: ffprobeExecutable,
    });
    await (0, execa_1.default)(await (0, ffmpeg_flags_1.getExecutableBinary)(ffmpegExecutable, remotionRoot, 'ffmpeg'), [
        '-i',
        src,
        '-fflags',
        '+genpts+igndts',
        '-vcodec',
        'copy',
        '-acodec',
        'copy',
        output,
        '-y',
    ]);
    return output;
};
exports.ensurePresentationTimestampWithoutCache = ensurePresentationTimestampWithoutCache;
const ensurePresentationTimestamps = async ({ downloadMap, src, remotionRoot, ffmpegExecutable, ffprobeExecutable, }) => {
    const elem = downloadMap.ensureFileHasPresentationTimestamp[src];
    if ((elem === null || elem === void 0 ? void 0 : elem.type) === 'encoding') {
        return new Promise((resolve) => {
            callbacks.push({
                src,
                fn: (newSrc) => resolve(newSrc),
            });
        });
    }
    if ((elem === null || elem === void 0 ? void 0 : elem.type) === 'done') {
        return elem.src;
    }
    downloadMap.ensureFileHasPresentationTimestamp[src] = { type: 'encoding' };
    const output = await (0, exports.ensurePresentationTimestampWithoutCache)({
        ffmpegExecutable,
        ffprobeExecutable,
        remotionRoot,
        src,
    });
    callbacks = callbacks.filter((c) => {
        if (c.src === src) {
            c.fn(output);
            return false;
        }
        return true;
    });
    downloadMap.ensureFileHasPresentationTimestamp[src] = {
        type: 'done',
        src: output,
    };
    return output;
};
exports.ensurePresentationTimestamps = ensurePresentationTimestamps;
