"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.warnAboutFfmpegVersion = exports.getBinaryDownloadUrl = exports.getExecutableBinary = exports.lambdaFfmpegPaths = exports.downloadBinary = exports.getFfmpegVersion = exports.parseFfmpegVersion = exports.ffmpegHasFeature = exports.ffmpegInNodeModules = exports.getFfmpegBuildInfo = void 0;
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const BrowserFetcher_1 = require("./browser/BrowserFetcher");
const validate_ffmpeg_1 = require("./validate-ffmpeg");
let buildConfig = null;
const listeners = {};
const isDownloading = {};
const getFfmpegBuildInfo = async (options) => {
    if (buildConfig !== null) {
        return buildConfig;
    }
    const data = await (0, execa_1.default)(await (0, exports.getExecutableBinary)(options.ffmpegExecutable, options.remotionRoot, 'ffmpeg'), ['-buildconf'], {
        reject: false,
    });
    buildConfig = data.stderr;
    return buildConfig;
};
exports.getFfmpegBuildInfo = getFfmpegBuildInfo;
const getFfmpegFolderName = (remotionRoot) => {
    return path_1.default.resolve(remotionRoot, 'node_modules/.ffmpeg');
};
const binaryPrefix = { ffmpeg: 'ffmpeg-', ffprobe: 'ffprobe-' };
const randomFfmpegRuntimeId = String(Math.random()).replace('0.', '');
const ffmpegInNodeModules = (remotionRoot, binary) => {
    const folderName = getFfmpegFolderName(remotionRoot);
    if (!fs_1.default.existsSync(folderName)) {
        fs_1.default.mkdirSync(folderName, {
            recursive: true,
        });
    }
    // Check if a version of FFMPEG is already installed.
    // To qualify, it must have the expected file size
    // to avoid finding binaries that are still being downloaded
    // A random ID is being assigned to the download to avoid conflicts when multiple Remotion processes are running
    const ffmpegInstalled = fs_1.default.readdirSync(folderName).find((filename) => {
        if (!filename.startsWith(binaryPrefix[binary])) {
            return false;
        }
        const dlUrl = (0, exports.getBinaryDownloadUrl)(binary);
        if (!dlUrl) {
            return false;
        }
        const expectedLength = dlUrl.contentLength;
        if (fs_1.default.statSync(path_1.default.join(folderName, filename)).size === expectedLength) {
            return true;
        }
        return false;
    });
    if (ffmpegInstalled) {
        return path_1.default.join(folderName, ffmpegInstalled);
    }
    return null;
};
exports.ffmpegInNodeModules = ffmpegInNodeModules;
const getFfmpegAbsolutePath = (remotionRoot, binary) => {
    const folderName = getFfmpegFolderName(remotionRoot);
    if (!fs_1.default.existsSync(folderName)) {
        fs_1.default.mkdirSync(folderName);
    }
    if (os_1.default.platform() === 'win32') {
        return path_1.default.resolve(folderName, `${binaryPrefix[binary]}${randomFfmpegRuntimeId}.exe`);
    }
    return path_1.default.resolve(folderName, `${binaryPrefix[binary]}${randomFfmpegRuntimeId}`);
};
const ffmpegHasFeature = async ({ ffmpegExecutable, feature, remotionRoot, }) => {
    if (ffmpegExecutable && !(0, validate_ffmpeg_1.customExecutableExists)(ffmpegExecutable)) {
        return false;
    }
    if (!(0, validate_ffmpeg_1.binaryExists)('ffmpeg')) {
        return false;
    }
    const config = await (0, exports.getFfmpegBuildInfo)({ ffmpegExecutable, remotionRoot });
    return config.includes(feature);
};
exports.ffmpegHasFeature = ffmpegHasFeature;
const parseFfmpegVersion = (buildconf) => {
    var _a;
    const match = buildconf.match(/ffmpeg version ([0-9]+).([0-9]+)(?:.([0-9]+))?/);
    if (!match) {
        return null;
    }
    return [Number(match[1]), Number(match[2]), Number((_a = match[3]) !== null && _a !== void 0 ? _a : 0)];
};
exports.parseFfmpegVersion = parseFfmpegVersion;
const getFfmpegVersion = async (options) => {
    const buildInfo = await (0, exports.getFfmpegBuildInfo)({
        ffmpegExecutable: options.ffmpegExecutable,
        remotionRoot: options.remotionRoot,
    });
    return (0, exports.parseFfmpegVersion)(buildInfo);
};
exports.getFfmpegVersion = getFfmpegVersion;
const waitForFfmpegToBeDownloaded = (url) => {
    return new Promise((resolve) => {
        if (!listeners[url]) {
            listeners[url] = [];
        }
        listeners[url].push((src) => resolve(src));
    });
};
const onProgress = (downloadedBytes, totalBytesToDownload, binary) => {
    console.log('Downloading ', binary, `${toMegabytes(downloadedBytes)}/${toMegabytes(totalBytesToDownload)}`);
};
const downloadBinary = async (remotionRoot, url, binary) => {
    const destinationPath = getFfmpegAbsolutePath(remotionRoot, binary);
    const onProgressCallback = (downloadedBytes, _totalBytes) => {
        onProgress(downloadedBytes, _totalBytes, binary);
    };
    isDownloading[url] = true;
    const totalBytes = await (0, BrowserFetcher_1._downloadFile)(url, destinationPath, onProgressCallback);
    onProgress(totalBytes, totalBytes, binary);
    if (os_1.default.platform() !== 'win32') {
        fs_1.default.chmodSync(destinationPath, '777');
    }
    isDownloading[url] = false;
    if (!listeners[url]) {
        listeners[url] = [];
    }
    listeners[url].forEach((listener) => listener(destinationPath));
    listeners[url] = [];
    return destinationPath;
};
exports.downloadBinary = downloadBinary;
exports.lambdaFfmpegPaths = {
    ffmpeg: '/opt/bin/ffmpeg',
    ffprobe: '/opt/bin/ffprobe',
};
const getExecutableBinary = (ffmpegExecutable, remotionRoot, binary) => {
    if (fs_1.default.existsSync(exports.lambdaFfmpegPaths[binary])) {
        return exports.lambdaFfmpegPaths[binary];
    }
    if (ffmpegExecutable && (0, validate_ffmpeg_1.customExecutableExists)(ffmpegExecutable)) {
        return ffmpegExecutable;
    }
    if ((0, validate_ffmpeg_1.binaryExists)(binary)) {
        return binary;
    }
    const dlUrl = (0, exports.getBinaryDownloadUrl)(binary);
    if (dlUrl && isDownloading[dlUrl.url]) {
        return waitForFfmpegToBeDownloaded(dlUrl.url);
    }
    const inNodeMod = (0, exports.ffmpegInNodeModules)(remotionRoot, binary);
    if (inNodeMod) {
        return inNodeMod;
    }
    if (!dlUrl) {
        throw new Error(`${binary} could not be installed automatically. Your architecture and OS combination (os = ${os_1.default.platform()}, arch = ${process.arch}) is not supported. Please install ${binary} manually and add "${binary}" to your PATH.`);
    }
    return (0, exports.downloadBinary)(remotionRoot, dlUrl.url, binary);
};
exports.getExecutableBinary = getExecutableBinary;
function toMegabytes(bytes) {
    const mb = bytes / 1024 / 1024;
    return `${Math.round(mb * 10) / 10} Mb`;
}
const getBinaryDownloadUrl = (binary) => {
    if (os_1.default.platform() === 'win32' && process.arch === 'x64') {
        return binary === 'ffmpeg'
            ? {
                url: 'https://remotion-ffmpeg-binaries.s3.eu-central-1.amazonaws.com/ffmpeg-win-x86.exe',
                contentLength: 127531008,
            }
            : {
                url: 'https://remotion-ffmpeg-binaries.s3.eu-central-1.amazonaws.com/ffprobe-win-x86.exe',
                contentLength: 127425536,
            };
    }
    if (os_1.default.platform() === 'darwin' && process.arch === 'arm64') {
        return binary === 'ffmpeg'
            ? {
                url: 'https://remotion-ffmpeg-binaries.s3.eu-central-1.amazonaws.com/ffmpeg-macos-arm64',
                contentLength: 42093320,
            }
            : {
                url: 'https://remotion-ffmpeg-binaries.s3.eu-central-1.amazonaws.com/ffprobe-macos-arm64-v2',
                contentLength: 46690008,
            };
    }
    if (os_1.default.platform() === 'darwin' && process.arch === 'x64') {
        return binary === 'ffmpeg'
            ? {
                url: 'https://remotion-ffmpeg-binaries.s3.eu-central-1.amazonaws.com/ffmpeg-macos-x86',
                contentLength: 78380700,
            }
            : {
                url: 'https://remotion-ffmpeg-binaries.s3.eu-central-1.amazonaws.com/ffprobe-macos-x86',
                contentLength: 77364284,
            };
    }
    if (os_1.default.platform() === 'linux' && process.arch === 'x64') {
        return binary === 'ffmpeg'
            ? {
                url: 'https://remotion-ffmpeg-binaries.s3.eu-central-1.amazonaws.com/ffmpeg-linux-amd64',
                contentLength: 78502560,
            }
            : {
                url: 'https://remotion-ffmpeg-binaries.s3.eu-central-1.amazonaws.com/ffprobe-linux-amd64',
                contentLength: 78400704,
            };
    }
    return null;
};
exports.getBinaryDownloadUrl = getBinaryDownloadUrl;
const printMessage = (ffmpegVersion) => {
    console.warn('⚠️Old FFMPEG version detected: ' + ffmpegVersion.join('.'));
    console.warn('   You need at least version 4.1.0.');
    console.warn('   Upgrade FFMPEG to get rid of this warning.');
};
const printBuildConfMessage = () => {
    console.error('⚠️  Unsupported FFMPEG version detected.');
    console.error("   Your version doesn't support the -buildconf flag");
    console.error('   Audio will not be supported and you may experience other issues.');
    console.error('   Upgrade FFMPEG to at least v4.1.0 to get rid of this warning.');
};
const warnAboutFfmpegVersion = ({ ffmpegVersion, buildConf, }) => {
    if (buildConf === null) {
        printBuildConfMessage();
        return;
    }
    if (ffmpegVersion === null) {
        return null;
    }
    const [major, minor] = ffmpegVersion;
    // 3.x and below definitely is too old
    if (major < 4) {
        printMessage(ffmpegVersion);
        return;
    }
    // 5.x will be all good
    if (major > 4) {
        return;
    }
    if (minor < 1) {
        printMessage(ffmpegVersion);
    }
};
exports.warnAboutFfmpegVersion = warnAboutFfmpegVersion;
