"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractFrameFromVideo = exports.getLastFrameOfVideo = void 0;
const execa_1 = __importDefault(require("execa"));
const get_video_stream_duration_1 = require("./assets/get-video-stream-duration");
const determine_resize_params_1 = require("./determine-resize-params");
const determine_vcodec_ffmpeg_flags_1 = require("./determine-vcodec-ffmpeg-flags");
const ensure_presentation_timestamp_1 = require("./ensure-presentation-timestamp");
const ffmpeg_flags_1 = require("./ffmpeg-flags");
const frame_to_ffmpeg_timestamp_1 = require("./frame-to-ffmpeg-timestamp");
const get_can_extract_frames_fast_1 = require("./get-can-extract-frames-fast");
const get_frame_of_video_slow_1 = require("./get-frame-of-video-slow");
const get_video_info_1 = require("./get-video-info");
const is_beyond_last_frame_1 = require("./is-beyond-last-frame");
const last_frame_from_video_cache_1 = require("./last-frame-from-video-cache");
const p_limit_1 = require("./p-limit");
const perf_1 = require("./perf");
const truthy_1 = require("./truthy");
const try_to_extract_frame_of_video_fast_1 = require("./try-to-extract-frame-of-video-fast");
const lastFrameLimit = (0, p_limit_1.pLimit)(1);
const mainLimit = (0, p_limit_1.pLimit)(5);
const getLastFrameOfVideoFastUnlimited = async (options) => {
    const { ffmpegExecutable, ffprobeExecutable, offset, src, downloadMap } = options;
    const fromCache = (0, last_frame_from_video_cache_1.getLastFrameFromCache)({ ...options, offset: 0 });
    if (fromCache) {
        return fromCache;
    }
    const { duration, fps } = await (0, get_video_stream_duration_1.getVideoStreamDuration)(downloadMap, src, ffprobeExecutable, options.remotionRoot);
    if (duration === null) {
        throw new Error(`Could not determine the duration of ${src} using FFMPEG. The file is not supported.`);
    }
    if (options.specialVCodecForTransparency === 'vp8' ||
        offset > get_can_extract_frames_fast_1.ACCEPTABLE_OFFSET_THRESHOLD) {
        const last = await (0, get_frame_of_video_slow_1.getFrameOfVideoSlow)({
            duration,
            ffmpegExecutable,
            src,
            imageFormat: options.imageFormat,
            specialVCodecForTransparency: options.specialVCodecForTransparency,
            needsResize: options.needsResize,
            offset: offset - 1000 / (fps === null ? 10 : fps),
            fps,
            remotionRoot: options.remotionRoot,
        });
        return last;
    }
    const actualOffset = `${duration * 1000 - offset}ms`;
    const [stdErr, stdoutBuffer] = await (0, try_to_extract_frame_of_video_fast_1.tryToExtractFrameOfVideoFast)({
        actualOffset,
        ffmpegExecutable,
        imageFormat: options.imageFormat,
        needsResize: options.needsResize,
        remotionRoot: options.remotionRoot,
        specialVCodecForTransparency: options.specialVCodecForTransparency,
        src,
    });
    const isEmpty = stdErr.includes('Output file is empty');
    if (isEmpty) {
        const unlimited = await getLastFrameOfVideoFastUnlimited({
            ffmpegExecutable,
            // Decrement in 10ms increments, or 1 frame (e.g. fps = 25 --> 40ms)
            offset: offset + (fps === null ? 10 : 1000 / fps),
            src,
            ffprobeExecutable,
            imageFormat: options.imageFormat,
            specialVCodecForTransparency: options.specialVCodecForTransparency,
            needsResize: options.needsResize,
            downloadMap: options.downloadMap,
            remotionRoot: options.remotionRoot,
        });
        return unlimited;
    }
    return stdoutBuffer;
};
const getLastFrameOfVideo = async (options) => {
    const result = await lastFrameLimit(getLastFrameOfVideoFastUnlimited, options);
    (0, last_frame_from_video_cache_1.setLastFrameInCache)(options, result);
    return result;
};
exports.getLastFrameOfVideo = getLastFrameOfVideo;
const extractFrameFromVideoFn = async ({ time, ffmpegExecutable, ffprobeExecutable, imageFormat, downloadMap, remotionRoot, ...options }) => {
    // We make a new copy of the video only for video because the conversion may affect
    // audio rendering, so we work with 2 different files
    const src = await (0, ensure_presentation_timestamp_1.ensurePresentationTimestamps)({
        downloadMap,
        src: options.src,
        remotionRoot,
        ffmpegExecutable,
        ffprobeExecutable,
    });
    const { specialVcodecForTransparency: specialVcodec, needsResize } = await (0, get_video_info_1.getVideoInfo)(downloadMap, src, ffprobeExecutable, remotionRoot);
    if (specialVcodec === 'vp8') {
        const { fps } = await (0, get_video_stream_duration_1.getVideoStreamDuration)(downloadMap, src, ffprobeExecutable, remotionRoot);
        return (0, get_frame_of_video_slow_1.getFrameOfVideoSlow)({
            ffmpegExecutable,
            imageFormat,
            specialVCodecForTransparency: specialVcodec,
            src,
            duration: time,
            needsResize,
            offset: 0,
            fps,
            remotionRoot,
        });
    }
    if ((0, is_beyond_last_frame_1.isBeyondLastFrame)(downloadMap, src, time)) {
        const lastFrame = await (0, exports.getLastFrameOfVideo)({
            ffmpegExecutable,
            ffprobeExecutable,
            offset: 0,
            src,
            imageFormat,
            specialVCodecForTransparency: specialVcodec,
            needsResize,
            downloadMap,
            remotionRoot,
        });
        return lastFrame;
    }
    const ffmpegTimestamp = (0, frame_to_ffmpeg_timestamp_1.frameToFfmpegTimestamp)(time);
    const { stdout, stderr } = (0, execa_1.default)(await (0, ffmpeg_flags_1.getExecutableBinary)(ffmpegExecutable, remotionRoot, 'ffmpeg'), [
        '-ss',
        ffmpegTimestamp,
        ...(0, determine_vcodec_ffmpeg_flags_1.determineVcodecFfmpegFlags)(specialVcodec),
        '-i',
        src,
        '-frames:v',
        '1',
        '-f',
        'image2pipe',
        '-vcodec',
        imageFormat === 'jpeg' ? 'mjpeg' : 'png',
        ...(0, determine_resize_params_1.determineResizeParams)(needsResize),
        '-',
    ].filter(truthy_1.truthy), {
        buffer: false,
    });
    if (!stderr) {
        throw new Error('unexpectedly did not get stderr');
    }
    if (!stdout) {
        throw new Error('unexpectedly did not get stdout');
    }
    const stdoutChunks = [];
    const stderrChunks = [];
    const stderrStringProm = new Promise((resolve, reject) => {
        stderr.on('data', (d) => stderrChunks.push(d));
        stderr.on('error', (err) => reject(err));
        stderr.on('end', () => resolve(Buffer.concat(stderrChunks).toString('utf8')));
    });
    const stdoutBuffer = new Promise((resolve, reject) => {
        stdout.on('data', (d) => stdoutChunks.push(d));
        stdout.on('error', (err) => reject(err));
        stdout.on('end', () => resolve(Buffer.concat(stdoutChunks)));
    });
    const [stderrStr, stdOut] = await Promise.all([
        stderrStringProm,
        stdoutBuffer,
    ]);
    if (stderrStr.includes('Output file is empty')) {
        (0, is_beyond_last_frame_1.markAsBeyondLastFrame)(downloadMap, src, time);
        const last = await (0, exports.getLastFrameOfVideo)({
            ffmpegExecutable,
            ffprobeExecutable,
            offset: 0,
            src,
            imageFormat,
            specialVCodecForTransparency: specialVcodec,
            needsResize,
            downloadMap,
            remotionRoot,
        });
        return last;
    }
    if (stdOut.length === 0) {
        console.log('FFMPEG Logs:');
        console.log(stderrStr);
        throw new Error("Couldn't extract frame from video - FFMPEG did not return any data. Check logs to see more information");
    }
    return stdOut;
};
const extractFrameFromVideo = async (options) => {
    const perf = (0, perf_1.startPerfMeasure)('extract-frame');
    const res = await mainLimit(extractFrameFromVideoFn, options);
    (0, perf_1.stopPerfMeasure)(perf);
    return res;
};
exports.extractFrameFromVideo = extractFrameFromVideo;
