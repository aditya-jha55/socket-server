import execa from 'execa';
import { SymbolicateableError } from './error-handling/symbolicateable-error';
import { mimeContentType, mimeLookup } from './mime-types';
import * as perf from './perf';
export type { RenderMediaOnDownload } from './assets/download-and-map-assets-to-file';
export type { DownloadMap } from './assets/download-map';
export { AudioCodec } from './audio-codec';
export { Browser } from './browser';
export { BrowserExecutable } from './browser-executable';
export { BrowserLog } from './browser-log';
export { Codec, CodecOrUndefined } from './codec';
export { Crf } from './crf';
export { ensureFfmpeg, EnsureFfmpegOptions, ensureFfprobe, } from './ensure-ffmpeg';
export { ErrorWithStackFrame } from './error-handling/handle-javascript-exception';
export { FfmpegExecutable } from './ffmpeg-executable';
export { FfmpegVersion } from './ffmpeg-flags';
export type { FfmpegOverrideFn } from './ffmpeg-override';
export { FileExtension } from './file-extensions';
export { FrameRange } from './frame-range';
export { getCanExtractFramesFast } from './get-can-extract-frames-fast';
export { getCompositions } from './get-compositions';
export { ImageFormat, StillImageFormat, validateSelectedPixelFormatAndImageFormatCombination, validImageFormats, } from './image-format';
export type { LogLevel } from './log-level';
export { CancelSignal, makeCancelSignal } from './make-cancel-signal';
export { openBrowser } from './open-browser';
export type { ChromiumOptions } from './open-browser';
export { PixelFormat } from './pixel-format';
export { ProResProfile } from './prores-profile';
export { renderFrames } from './render-frames';
export { OnSlowestFrames, renderMedia, RenderMediaOnProgress, RenderMediaOptions, SlowFrame, StitchingState, } from './render-media';
export { renderStill, RenderStillOptions } from './render-still';
export { StitcherOptions, stitchFramesToVideo } from './stitch-frames-to-video';
export { SymbolicatedStackFrame } from './symbolicate-stacktrace';
export { OnStartData, RenderFramesOutput } from './types';
export { OpenGlRenderer } from './validate-opengl-renderer';
export { validateOutputFilename } from './validate-output-filename';
export declare const RenderInternals: {
    ensureLocalBrowser: (browser: import("./browser").Browser, preferredBrowserExecutable: import("./browser-executable").BrowserExecutable) => Promise<void>;
    ffmpegHasFeature: ({ ffmpegExecutable, feature, remotionRoot, }: {
        ffmpegExecutable: string | null;
        feature: "enable-gpl" | "enable-libx265" | "enable-libvpx";
        remotionRoot: string;
    }) => Promise<boolean>;
    getActualConcurrency: (userPreference: string | number | null) => number;
    validateFfmpeg: (customFfmpegBinary: string | null, remotionRoot: string, binary: "ffmpeg" | "ffprobe") => Promise<void>;
    serveStatic: (path: string | null, options: {
        port: number | null;
        ffmpegExecutable: import("./ffmpeg-executable").FfmpegExecutable;
        ffprobeExecutable: import("./ffmpeg-executable").FfmpegExecutable;
        onDownload: import("./assets/download-and-map-assets-to-file").RenderMediaOnDownload;
        onError: (err: Error) => void;
        downloadMap: import("./assets/download-map").DownloadMap;
        remotionRoot: string;
    }) => Promise<{
        port: number;
        close: () => Promise<void>;
    }>;
    validateEvenDimensionsWithCodec: ({ width, height, codec, scale, }: {
        width: number;
        height: number;
        scale: number;
        codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif";
    }) => void;
    getFileExtensionFromCodec: <T extends "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif">(codec: T, audioCodec: "mp3" | "aac" | "pcm-16" | "opus" | null) => import("./file-extensions").FileExtension;
    tmpDir: (str: string) => string;
    deleteDirectory: (directory: string) => void;
    isServeUrl: (potentialUrl: string) => boolean;
    ensureOutputDirectory: (outputLocation: string) => void;
    getRealFrameRange: (durationInFrames: number, frameRange: import("./frame-range").FrameRange | null) => [number, number];
    validatePuppeteerTimeout: (timeoutInMilliseconds: unknown) => void;
    downloadFile: ({ onProgress, url, to: toFn, }: {
        url: string;
        to: (contentDisposition: string | null, contentType: string | null) => string;
        onProgress: ((progress: {
            percent: number | null;
            downloaded: number;
            totalSize: number | null;
        }) => void) | undefined;
    }) => Promise<{
        sizeInBytes: number;
        to: string;
    }>;
    killAllBrowsers: () => Promise<void>;
    parseStack: (stack: string[]) => import("./parse-browser-error-stack").UnsymbolicatedStackFrame[];
    symbolicateError: (symbolicateableError: SymbolicateableError) => Promise<import("./error-handling/handle-javascript-exception").ErrorWithStackFrame>;
    SymbolicateableError: typeof SymbolicateableError;
    getFramesToRender: (frameRange: [number, number], everyNthFrame: number) => number[];
    getExtensionOfFilename: (filename: string | null) => string | null;
    getDesiredPort: (desiredPort: number | undefined, from: number, to: number) => Promise<{
        port: number;
        didUsePort: () => void;
    }>;
    isPathInside: (thePath: string, potentialParent: string) => boolean;
    execa: {
        (file: string, arguments?: readonly string[] | undefined, options?: execa.Options<string> | undefined): execa.ExecaChildProcess<string>;
        (file: string, arguments?: readonly string[] | undefined, options?: execa.Options<null> | undefined): execa.ExecaChildProcess<Buffer>;
        (file: string, options?: execa.Options<string> | undefined): execa.ExecaChildProcess<string>;
        (file: string, options?: execa.Options<null> | undefined): execa.ExecaChildProcess<Buffer>;
        sync(file: string, arguments?: readonly string[] | undefined, options?: execa.SyncOptions<string> | undefined): execa.ExecaSyncReturnValue<string>;
        sync(file: string, arguments?: readonly string[] | undefined, options?: execa.SyncOptions<null> | undefined): execa.ExecaSyncReturnValue<Buffer>;
        sync(file: string, options?: execa.SyncOptions<string> | undefined): execa.ExecaSyncReturnValue<string>;
        sync(file: string, options?: execa.SyncOptions<null> | undefined): execa.ExecaSyncReturnValue<Buffer>;
        command(command: string, options?: execa.Options<string> | undefined): execa.ExecaChildProcess<string>;
        command(command: string, options?: execa.Options<null> | undefined): execa.ExecaChildProcess<Buffer>;
        commandSync(command: string, options?: execa.SyncOptions<string> | undefined): execa.ExecaSyncReturnValue<string>;
        commandSync(command: string, options?: execa.SyncOptions<null> | undefined): execa.ExecaSyncReturnValue<Buffer>;
        node(scriptPath: string, arguments?: readonly string[] | undefined, options?: execa.NodeOptions<string> | undefined): execa.ExecaChildProcess<string>;
        node(scriptPath: string, arguments?: readonly string[] | undefined, options?: execa.Options<null> | undefined): execa.ExecaChildProcess<Buffer>;
        node(scriptPath: string, options?: execa.Options<string> | undefined): execa.ExecaChildProcess<string>;
        node(scriptPath: string, options?: execa.Options<null> | undefined): execa.ExecaChildProcess<Buffer>;
    };
    registerErrorSymbolicationLock: () => number;
    unlockErrorSymbolicationLock: (id: number) => void;
    canUseParallelEncoding: (codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif") => boolean;
    mimeContentType: typeof mimeContentType;
    mimeLookup: typeof mimeLookup;
    validateConcurrency: (value: unknown, setting: string) => void;
    validPixelFormats: readonly ["yuv420p", "yuva420p", "yuv422p", "yuv444p", "yuv420p10le", "yuv422p10le", "yuv444p10le", "yuva444p10le"];
    DEFAULT_BROWSER: import("./browser").Browser;
    validateFrameRange: (frameRange: import("./frame-range").FrameRange | null) => void;
    DEFAULT_OPENGL_RENDERER: "swangle" | "angle" | "egl" | "swiftshader" | null;
    validateOpenGlRenderer: (option: "swangle" | "angle" | "egl" | "swiftshader" | null) => "swangle" | "angle" | "egl" | "swiftshader" | null;
    validImageFormats: readonly ["png", "jpeg", "none"];
    validCodecs: readonly ["h264", "h265", "vp8", "vp9", "mp3", "aac", "wav", "prores", "h264-mkv", "gif"];
    DEFAULT_PIXEL_FORMAT: "yuv420p" | "yuva420p" | "yuv422p" | "yuv444p" | "yuv420p10le" | "yuv422p10le" | "yuv444p10le" | "yuva444p10le";
    validateQuality: (q: number | undefined) => void;
    DEFAULT_TIMEOUT: number;
    DEFAULT_CODEC: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif";
    isAudioCodec: (codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif" | undefined) => boolean;
    logLevels: readonly ["verbose", "info", "warn", "error"];
    isEqualOrBelowLogLevel: (currentLevel: "verbose" | "error" | "info" | "warn", level: "verbose" | "error" | "info" | "warn") => boolean;
    isValidLogLevel: (level: string) => boolean;
    perf: typeof perf;
    makeDownloadMap: () => import("./assets/download-map").DownloadMap;
    cleanDownloadMap: (downloadMap: import("./assets/download-map").DownloadMap) => void;
    convertToPositiveFrameIndex: ({ frame, durationInFrames, }: {
        frame: number;
        durationInFrames: number;
    }) => number;
    findRemotionRoot: () => string;
    getExecutableBinary: (ffmpegExecutable: import("./ffmpeg-executable").FfmpegExecutable, remotionRoot: string, binary: "ffmpeg" | "ffprobe") => string | Promise<string>;
    validateBitrate: (bitrate: unknown, name: string) => void;
    getFfmpegVersion: (options: {
        ffmpegExecutable: string | null;
        remotionRoot: string;
    }) => Promise<import("./ffmpeg-flags").FfmpegVersion>;
    combineVideos: (options: {
        files: string[];
        filelistDir: string;
        output: string;
        onProgress: (p: number) => void;
        numberOfFrames: number;
        codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif";
        fps: number;
        numberOfGifLoops: number | null;
        remotionRoot: string;
        ffmpegExecutable: import("./ffmpeg-executable").FfmpegExecutable;
        audioCodec: "mp3" | "aac" | "pcm-16" | "opus" | null;
    }) => Promise<void>;
    getDefaultAudioCodec: ({ codec, preferLossless, }: {
        codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif";
        preferLossless: boolean;
    }) => "mp3" | "aac" | "pcm-16" | "opus" | null;
    validAudioCodecs: readonly ["pcm-16", "aac", "mp3", "opus"];
    defaultFileExtensionMap: {
        h264: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                aac: {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        h265: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                aac: {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        vp8: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
                opus: {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        vp9: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
                opus: {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        mp3: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                mp3: {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        aac: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                aac: {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        wav: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        prores: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                aac: {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        "h264-mkv": {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {
                "pcm-16": {
                    possible: import("./file-extensions").FileExtension[];
                    default: import("./file-extensions").FileExtension;
                };
            };
        };
        gif: {
            default: import("./file-extensions").FileExtension;
            forAudioCodec: {};
        };
    };
    supportedAudioCodecs: {
        readonly h264: readonly ["aac", "pcm-16"];
        readonly 'h264-mkv': readonly ["pcm-16"];
        readonly aac: readonly ["aac", "pcm-16"];
        readonly gif: readonly [];
        readonly h265: readonly ["aac", "pcm-16"];
        readonly mp3: readonly ["mp3", "pcm-16"];
        readonly prores: readonly ["pcm-16", "aac"];
        readonly vp8: readonly ["opus", "pcm-16"];
        readonly vp9: readonly ["opus", "pcm-16"];
        readonly wav: readonly ["pcm-16"];
    };
    makeFileExtensionMap: () => Record<string, ("h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif")[]>;
    defaultCodecsForFileExtension: Record<import("./file-extensions").FileExtension, "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif">;
};
