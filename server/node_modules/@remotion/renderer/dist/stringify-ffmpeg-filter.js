"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyFfmpegFilter = void 0;
const calculate_atempo_1 = require("./assets/calculate-atempo");
const ffmpeg_volume_expression_1 = require("./assets/ffmpeg-volume-expression");
const sample_rate_1 = require("./sample-rate");
const truthy_1 = require("./truthy");
const stringifyFfmpegFilter = ({ trimLeft, trimRight, channels, startInVideo, volume, fps, playbackRate, durationInFrames, assetDuration, allowAmplificationDuringRender, }) => {
    const startInVideoSeconds = startInVideo / fps;
    if (assetDuration && trimLeft >= assetDuration) {
        return null;
    }
    const volumeFilter = (0, ffmpeg_volume_expression_1.ffmpegVolumeExpression)({
        volume,
        fps,
        trimLeft,
        allowAmplificationDuringRender,
    });
    // Avoid setting filters if possible, as combining them can create noise
    const chunkLength = durationInFrames / fps;
    const actualTrimRight = assetDuration
        ? Math.min(trimRight, assetDuration)
        : trimRight;
    const audibleDuration = (actualTrimRight - trimLeft) / playbackRate;
    const padAtEnd = chunkLength - audibleDuration - startInVideoSeconds;
    return {
        filter: `[0:a]` +
            [
                `aformat=sample_fmts=s32:sample_rates=${sample_rate_1.DEFAULT_SAMPLE_RATE}`,
                // Order matters! First trim the audio
                `atrim=${trimLeft.toFixed(6)}:${actualTrimRight.toFixed(6)}`,
                // then set the tempo
                (0, calculate_atempo_1.calculateATempo)(playbackRate),
                // set the volume if needed
                // The timings for volume must include whatever is in atrim, unless the volume
                // filter gets applied before atrim
                volumeFilter.value === '1'
                    ? null
                    : `volume=${volumeFilter.value}:eval=${volumeFilter.eval}`,
                // For n channels, we delay n + 1 channels.
                // This is because `ffprobe` for some audio files reports the wrong amount
                // of channels.
                // This should be fine because FFMPEG documentation states:
                // "Unused delays will be silently ignored."
                // https://ffmpeg.org/ffmpeg-filters.html#adelay
            ]
                .filter(truthy_1.truthy)
                .join(',') +
            `[a0]`,
        pad_end: padAtEnd > 0.0000001
            ? 'apad=pad_len=' + Math.round(padAtEnd * sample_rate_1.DEFAULT_SAMPLE_RATE)
            : null,
        pad_start: startInVideoSeconds === 0
            ? null
            : `adelay=${new Array(channels + 1)
                .fill((startInVideoSeconds * 1000).toFixed(0))
                .join('|')}`,
    };
};
exports.stringifyFfmpegFilter = stringifyFfmpegFilter;
