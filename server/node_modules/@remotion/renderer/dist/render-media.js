"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderMedia = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const remotion_1 = require("remotion");
const download_map_1 = require("./assets/download-map");
const can_use_parallel_encoding_1 = require("./can-use-parallel-encoding");
const codec_supports_media_1 = require("./codec-supports-media");
const crf_1 = require("./crf");
const delete_directory_1 = require("./delete-directory");
const ensure_frames_in_order_1 = require("./ensure-frames-in-order");
const ensure_output_directory_1 = require("./ensure-output-directory");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_duration_from_frame_range_1 = require("./get-duration-from-frame-range");
const get_extension_from_codec_1 = require("./get-extension-from-codec");
const get_extension_of_filename_1 = require("./get-extension-of-filename");
const get_frame_to_render_1 = require("./get-frame-to-render");
const image_format_1 = require("./image-format");
const is_audio_codec_1 = require("./is-audio-codec");
const legacy_webpack_config_1 = require("./legacy-webpack-config");
const make_cancel_signal_1 = require("./make-cancel-signal");
const overwrite_1 = require("./overwrite");
const perf_1 = require("./perf");
const pixel_format_1 = require("./pixel-format");
const prespawn_ffmpeg_1 = require("./prespawn-ffmpeg");
const prestitcher_memory_usage_1 = require("./prestitcher-memory-usage");
const prores_profile_1 = require("./prores-profile");
const quality_1 = require("./quality");
const render_frames_1 = require("./render-frames");
const stitch_frames_to_video_1 = require("./stitch-frames-to-video");
const validate_even_dimensions_with_codec_1 = require("./validate-even-dimensions-with-codec");
const validate_every_nth_frame_1 = require("./validate-every-nth-frame");
const validate_ffmpeg_1 = require("./validate-ffmpeg");
const validate_ffmpeg_override_1 = require("./validate-ffmpeg-override");
const validate_output_filename_1 = require("./validate-output-filename");
const validate_scale_1 = require("./validate-scale");
const validate_videobitrate_1 = require("./validate-videobitrate");
const SLOWEST_FRAME_COUNT = 10;
const getConcurrency = (others) => {
    if ('concurrency' in others) {
        return others.concurrency;
    }
    if ('parallelism' in others) {
        return others.parallelism;
    }
    return null;
};
/**
 *
 * @description Render a video from a composition
 * @see [Documentation](https://www.remotion.dev/docs/renderer/render-media)
 */
const renderMedia = ({ proResProfile, crf, composition, ffmpegExecutable, ffprobeExecutable, inputProps, pixelFormat, codec, envVariables, frameRange, puppeteerInstance, outputLocation, onProgress, overwrite, onDownload, dumpBrowserLogs, onBrowserLog, onStart, timeoutInMilliseconds, chromiumOptions, scale, browserExecutable, port, cancelSignal, muted, enforceAudioTrack, ffmpegOverride, audioBitrate, videoBitrate, onSlowestFrames, audioCodec, ...options }) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const remotionRoot = (0, find_closest_package_json_1.findRemotionRoot)();
    (0, validate_ffmpeg_1.validateFfmpeg)(ffmpegExecutable !== null && ffmpegExecutable !== void 0 ? ffmpegExecutable : null, remotionRoot, 'ffmpeg');
    (0, quality_1.validateQuality)(options.quality);
    (0, crf_1.validateQualitySettings)({ crf, codec, videoBitrate });
    (0, validate_videobitrate_1.validateBitrate)(audioBitrate, 'audioBitrate');
    (0, validate_videobitrate_1.validateBitrate)(videoBitrate, 'videoBitrate');
    (0, prores_profile_1.validateSelectedCodecAndProResCombination)({
        codec,
        proResProfile,
    });
    (0, pixel_format_1.validateSelectedPixelFormatAndCodecCombination)(pixelFormat, codec);
    if (outputLocation) {
        (0, validate_output_filename_1.validateOutputFilename)({
            codec,
            audioCodec: audioCodec !== null && audioCodec !== void 0 ? audioCodec : null,
            extension: (0, get_extension_of_filename_1.getExtensionOfFilename)(outputLocation),
            preferLossless: (_a = options.preferLossless) !== null && _a !== void 0 ? _a : false,
        });
    }
    const absoluteOutputLocation = outputLocation
        ? path_1.default.resolve(process.cwd(), outputLocation)
        : null;
    (0, validate_scale_1.validateScale)(scale);
    const concurrency = getConcurrency(options);
    (0, validate_ffmpeg_override_1.validateFfmpegOverride)(ffmpegOverride);
    const everyNthFrame = (_b = options.everyNthFrame) !== null && _b !== void 0 ? _b : 1;
    (0, validate_every_nth_frame_1.validateEveryNthFrame)(everyNthFrame, codec);
    const numberOfGifLoops = (_c = options.numberOfGifLoops) !== null && _c !== void 0 ? _c : null;
    const serveUrl = (0, legacy_webpack_config_1.getServeUrlWithFallback)(options);
    let stitchStage = 'encoding';
    let stitcherFfmpeg;
    let preStitcher = null;
    let encodedFrames = 0;
    let renderedFrames = 0;
    let renderedDoneIn = null;
    let encodedDoneIn = null;
    let cancelled = false;
    const renderStart = Date.now();
    const downloadMap = (_e = (_d = options.internal) === null || _d === void 0 ? void 0 : _d.downloadMap) !== null && _e !== void 0 ? _e : (0, download_map_1.makeDownloadMap)();
    const { estimatedUsage, freeMemory, hasEnoughMemory } = (0, prestitcher_memory_usage_1.shouldUseParallelEncoding)({
        height: composition.height,
        width: composition.width,
    });
    const parallelEncoding = !options.disallowParallelEncoding &&
        hasEnoughMemory &&
        (0, can_use_parallel_encoding_1.canUseParallelEncoding)(codec);
    if (options.verbose) {
        console.log('[PRESTITCHER] Free memory:', freeMemory, 'Estimated usage parallel encoding', estimatedUsage);
        console.log('[PRESTITCHER]: Codec supports parallel rendering:', (0, can_use_parallel_encoding_1.canUseParallelEncoding)(codec));
        console.log('[PRESTITCHER]: User disallowed parallel encoding:', Boolean(options.disallowParallelEncoding));
        if (parallelEncoding) {
            console.log('[PRESTITCHER] Parallel encoding is enabled.');
        }
        else {
            console.log('[PRESTITCHER] Parallel encoding is disabled.');
        }
    }
    const imageFormat = (0, is_audio_codec_1.isAudioCodec)(codec)
        ? 'none'
        : (_f = options.imageFormat) !== null && _f !== void 0 ? _f : 'jpeg';
    const quality = imageFormat === 'jpeg' ? options.quality : undefined;
    (0, image_format_1.validateSelectedPixelFormatAndImageFormatCombination)(pixelFormat, imageFormat);
    const preEncodedFileLocation = parallelEncoding
        ? path_1.default.join(downloadMap.preEncode, 'pre-encode.' + (0, get_extension_from_codec_1.getFileExtensionFromCodec)(codec, audioCodec !== null && audioCodec !== void 0 ? audioCodec : null))
        : null;
    const outputDir = parallelEncoding
        ? null
        : fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), 'react-motion-render'));
    if (((_g = options.internal) === null || _g === void 0 ? void 0 : _g.onCtrlCExit) && outputDir) {
        options.internal.onCtrlCExit(() => (0, delete_directory_1.deleteDirectory)(outputDir));
    }
    (0, validate_even_dimensions_with_codec_1.validateEvenDimensionsWithCodec)({
        codec,
        height: composition.height,
        scale: scale !== null && scale !== void 0 ? scale : 1,
        width: composition.width,
    });
    const callUpdate = () => {
        onProgress === null || onProgress === void 0 ? void 0 : onProgress({
            encodedDoneIn,
            encodedFrames,
            renderedDoneIn,
            renderedFrames,
            stitchStage,
            progress: Math.round(((0.7 * renderedFrames + 0.3 * encodedFrames) /
                composition.durationInFrames) *
                100) / 100,
        });
    };
    const realFrameRange = (0, get_frame_to_render_1.getRealFrameRange)(composition.durationInFrames, frameRange !== null && frameRange !== void 0 ? frameRange : null);
    const cancelRenderFrames = (0, make_cancel_signal_1.makeCancelSignal)();
    const cancelPrestitcher = (0, make_cancel_signal_1.makeCancelSignal)();
    const cancelStitcher = (0, make_cancel_signal_1.makeCancelSignal)();
    cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
        cancelRenderFrames.cancel();
    });
    const { waitForRightTimeOfFrameToBeInserted, setFrameToStitch, waitForFinish } = (0, ensure_frames_in_order_1.ensureFramesInOrder)(realFrameRange);
    const fps = composition.fps / (everyNthFrame !== null && everyNthFrame !== void 0 ? everyNthFrame : 1);
    remotion_1.Internals.validateFps(fps, 'in "renderMedia()"', codec === 'gif');
    const createPrestitcherIfNecessary = async () => {
        var _a;
        if (preEncodedFileLocation) {
            preStitcher = await (0, prespawn_ffmpeg_1.prespawnFfmpeg)({
                width: composition.width * (scale !== null && scale !== void 0 ? scale : 1),
                height: composition.height * (scale !== null && scale !== void 0 ? scale : 1),
                fps,
                outputLocation: preEncodedFileLocation,
                pixelFormat,
                codec,
                proResProfile,
                crf,
                onProgress: (frame) => {
                    encodedFrames = frame;
                    callUpdate();
                },
                verbose: (_a = options.verbose) !== null && _a !== void 0 ? _a : false,
                ffmpegExecutable,
                imageFormat,
                signal: cancelPrestitcher.cancelSignal,
                ffmpegOverride: ffmpegOverride !== null && ffmpegOverride !== void 0 ? ffmpegOverride : (({ args }) => args),
                videoBitrate: videoBitrate !== null && videoBitrate !== void 0 ? videoBitrate : null,
            }, remotionRoot);
            stitcherFfmpeg = preStitcher.task;
        }
    };
    const waitForPrestitcherIfNecessary = async () => {
        var _a;
        if (stitcherFfmpeg) {
            await waitForFinish();
            (_a = stitcherFfmpeg === null || stitcherFfmpeg === void 0 ? void 0 : stitcherFfmpeg.stdin) === null || _a === void 0 ? void 0 : _a.end();
            try {
                await stitcherFfmpeg;
            }
            catch (err) {
                throw new Error(preStitcher === null || preStitcher === void 0 ? void 0 : preStitcher.getLogs());
            }
        }
    };
    const mediaSupport = (0, codec_supports_media_1.codecSupportsMedia)(codec);
    const disableAudio = !mediaSupport.audio || muted;
    const slowestFrames = [];
    let maxTime = 0;
    let minTime = 0;
    const recordFrameTime = (frameIndex, time) => {
        var _a, _b;
        const frameTime = { frame: frameIndex, time };
        if (time < minTime && slowestFrames.length === SLOWEST_FRAME_COUNT) {
            return;
        }
        if (time > maxTime) {
            // add at starting;
            slowestFrames.unshift(frameTime);
            maxTime = time;
        }
        else {
            // add frame at appropriate position
            const index = slowestFrames.findIndex(({ time: indexTime }) => indexTime < time);
            slowestFrames.splice(index, 0, frameTime);
        }
        if (slowestFrames.length > SLOWEST_FRAME_COUNT) {
            slowestFrames.pop();
        }
        minTime = (_b = (_a = slowestFrames[slowestFrames.length - 1]) === null || _a === void 0 ? void 0 : _a.time) !== null && _b !== void 0 ? _b : minTime;
    };
    const happyPath = createPrestitcherIfNecessary()
        .then(() => {
        const renderFramesProc = (0, render_frames_1.renderFrames)({
            config: composition,
            onFrameUpdate: (frame, frameIndex, timeToRenderInMilliseconds) => {
                renderedFrames = frame;
                callUpdate();
                recordFrameTime(frameIndex, timeToRenderInMilliseconds);
            },
            concurrency,
            outputDir,
            onStart: (data) => {
                renderedFrames = 0;
                callUpdate();
                onStart === null || onStart === void 0 ? void 0 : onStart(data);
            },
            inputProps,
            envVariables,
            imageFormat,
            quality,
            frameRange: frameRange !== null && frameRange !== void 0 ? frameRange : null,
            puppeteerInstance,
            everyNthFrame,
            onFrameBuffer: parallelEncoding
                ? async (buffer, frame) => {
                    var _a;
                    await waitForRightTimeOfFrameToBeInserted(frame);
                    if (cancelled) {
                        return;
                    }
                    const id = (0, perf_1.startPerfMeasure)('piping');
                    (_a = stitcherFfmpeg === null || stitcherFfmpeg === void 0 ? void 0 : stitcherFfmpeg.stdin) === null || _a === void 0 ? void 0 : _a.write(buffer);
                    (0, perf_1.stopPerfMeasure)(id);
                    setFrameToStitch(Math.min(realFrameRange[1] + 1, frame + everyNthFrame));
                }
                : undefined,
            serveUrl,
            dumpBrowserLogs,
            onBrowserLog,
            onDownload,
            timeoutInMilliseconds,
            chromiumOptions,
            scale,
            ffmpegExecutable,
            ffprobeExecutable,
            browserExecutable,
            port,
            cancelSignal: cancelRenderFrames.cancelSignal,
            downloadMap,
            muted: disableAudio,
        });
        return renderFramesProc;
    })
        .then((renderFramesReturn) => {
        return Promise.all([renderFramesReturn, waitForPrestitcherIfNecessary()]);
    })
        .then(([{ assetsInfo }]) => {
        var _a;
        renderedDoneIn = Date.now() - renderStart;
        callUpdate();
        if (absoluteOutputLocation) {
            (0, ensure_output_directory_1.ensureOutputDirectory)(absoluteOutputLocation);
        }
        const stitchStart = Date.now();
        return Promise.all([
            (0, stitch_frames_to_video_1.stitchFramesToVideo)({
                width: composition.width * (scale !== null && scale !== void 0 ? scale : 1),
                height: composition.height * (scale !== null && scale !== void 0 ? scale : 1),
                fps,
                outputLocation: absoluteOutputLocation,
                internalOptions: {
                    preEncodedFileLocation,
                    imageFormat,
                    preferLossless: (_a = options.preferLossless) !== null && _a !== void 0 ? _a : false,
                },
                force: overwrite !== null && overwrite !== void 0 ? overwrite : overwrite_1.DEFAULT_OVERWRITE,
                pixelFormat,
                codec,
                proResProfile,
                crf,
                assetsInfo,
                ffmpegExecutable,
                ffprobeExecutable,
                onProgress: (frame) => {
                    stitchStage = 'muxing';
                    encodedFrames = frame;
                    callUpdate();
                },
                onDownload,
                numberOfGifLoops,
                verbose: options.verbose,
                dir: outputDir !== null && outputDir !== void 0 ? outputDir : undefined,
                cancelSignal: cancelStitcher.cancelSignal,
                muted: disableAudio,
                enforceAudioTrack,
                ffmpegOverride,
                audioBitrate,
                videoBitrate,
                audioCodec: audioCodec !== null && audioCodec !== void 0 ? audioCodec : null,
            }),
            stitchStart,
        ]);
    })
        .then(([buffer, stitchStart]) => {
        encodedFrames = (0, get_duration_from_frame_range_1.getFramesToRender)(realFrameRange, everyNthFrame).length;
        encodedDoneIn = Date.now() - stitchStart;
        callUpdate();
        slowestFrames.sort((a, b) => b.time - a.time);
        onSlowestFrames === null || onSlowestFrames === void 0 ? void 0 : onSlowestFrames(slowestFrames);
        return buffer;
    })
        .catch((err) => {
        /**
         * When an error is thrown in renderFrames(...) (e.g., when delayRender() is used incorrectly), fs.unlinkSync(...) throws an error that the file is locked because ffmpeg is still running, and renderMedia returns it.
         * Therefore we first kill the FFMPEG process before deleting the file
         */
        cancelled = true;
        cancelRenderFrames.cancel();
        cancelStitcher.cancel();
        cancelPrestitcher.cancel();
        if (stitcherFfmpeg !== undefined && stitcherFfmpeg.exitCode === null) {
            const promise = new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, 2000);
                stitcherFfmpeg.on('close', resolve);
            });
            stitcherFfmpeg.kill();
            return promise.then(() => {
                throw err;
            });
        }
        throw err;
    })
        .finally(() => {
        var _a;
        if (preEncodedFileLocation !== null &&
            fs_1.default.existsSync(preEncodedFileLocation)) {
            (0, delete_directory_1.deleteDirectory)(path_1.default.dirname(preEncodedFileLocation));
        }
        // Clean download map if it was not passed in
        if (!((_a = options.internal) === null || _a === void 0 ? void 0 : _a.downloadMap)) {
            (0, download_map_1.cleanDownloadMap)(downloadMap);
        }
        // Clean temporary image frames when rendering ends or fails
        if (outputDir && fs_1.default.existsSync(outputDir)) {
            (0, delete_directory_1.deleteDirectory)(outputDir);
        }
    });
    return Promise.race([
        happyPath,
        new Promise((_resolve, reject) => {
            cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
                reject(new Error(make_cancel_signal_1.cancelErrorMessages.renderMedia));
            });
        }),
    ]);
};
exports.renderMedia = renderMedia;
