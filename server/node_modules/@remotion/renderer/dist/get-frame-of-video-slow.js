"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFrameOfVideoSlow = void 0;
// Uses no seeking, therefore the whole video has to be decoded. This is a last resort and should only happen
// if the video is corrupted
const execa_1 = __importDefault(require("execa"));
const determine_resize_params_1 = require("./determine-resize-params");
const determine_vcodec_ffmpeg_flags_1 = require("./determine-vcodec-ffmpeg-flags");
const ffmpeg_flags_1 = require("./ffmpeg-flags");
const truthy_1 = require("./truthy");
const getFrameOfVideoSlow = async ({ src, duration, ffmpegExecutable, imageFormat, specialVCodecForTransparency, needsResize, offset, fps, remotionRoot, }) => {
    console.warn(`\nUsing a slow method to extract the frame at ${duration}ms of ${src}. See https://remotion.dev/docs/slow-method-to-extract-frame for advice`);
    const actualOffset = `-${duration * 1000 - offset}ms`;
    const command = [
        '-itsoffset',
        actualOffset,
        ...(0, determine_vcodec_ffmpeg_flags_1.determineVcodecFfmpegFlags)(specialVCodecForTransparency),
        '-i',
        src,
        '-frames:v',
        '1',
        '-c:v',
        imageFormat === 'jpeg' ? 'mjpeg' : 'png',
        '-f',
        'image2pipe',
        ...(0, determine_resize_params_1.determineResizeParams)(needsResize),
        '-',
    ].filter(truthy_1.truthy);
    const { stdout, stderr } = (0, execa_1.default)(await (0, ffmpeg_flags_1.getExecutableBinary)(ffmpegExecutable, remotionRoot, 'ffmpeg'), command);
    if (!stderr) {
        throw new Error('unexpectedly did not get stderr');
    }
    if (!stdout) {
        throw new Error('unexpectedly did not get stdout');
    }
    const stderrChunks = [];
    const stdoutChunks = [];
    const stdErrString = new Promise((resolve, reject) => {
        stderr.on('data', (d) => stderrChunks.push(d));
        stderr.on('error', (err) => reject(err));
        stderr.on('end', () => resolve(Buffer.concat(stderrChunks).toString('utf-8')));
    });
    const stdoutChunk = new Promise((resolve, reject) => {
        stdout.on('data', (d) => stdoutChunks.push(d));
        stdout.on('error', (err) => reject(err));
        stdout.on('end', () => resolve(Buffer.concat(stdoutChunks)));
    });
    const [stdErr, stdoutBuffer] = await Promise.all([stdErrString, stdoutChunk]);
    const isEmpty = stdErr.includes('Output file is empty');
    if (isEmpty) {
        if (offset > 70) {
            throw new Error(`Could not get last frame of ${src}. Tried to seek to the end using the command "ffmpeg ${command.join(' ')}" but got no frame. Most likely this video is corrupted.`);
        }
        return (0, exports.getFrameOfVideoSlow)({
            ffmpegExecutable,
            duration,
            // Decrement in 10ms increments, or 1 frame (e.g. fps = 25 --> 40ms)
            offset: offset + (fps === null ? 10 : 1000 / fps),
            src,
            imageFormat,
            specialVCodecForTransparency,
            needsResize,
            fps,
            remotionRoot,
        });
    }
    return stdoutBuffer;
};
exports.getFrameOfVideoSlow = getFrameOfVideoSlow;
