"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCanExtractFramesFast = exports.ACCEPTABLE_OFFSET_THRESHOLD = void 0;
const fs_1 = __importDefault(require("fs"));
const get_video_stream_duration_1 = require("./assets/get-video-stream-duration");
const ensure_presentation_timestamp_1 = require("./ensure-presentation-timestamp");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_video_info_1 = require("./get-video-info");
const try_to_extract_frame_of_video_fast_1 = require("./try-to-extract-frame-of-video-fast");
exports.ACCEPTABLE_OFFSET_THRESHOLD = 50;
/**
 * @description Probes whether frames of a video can be efficiently extracted when using <OffthreadVideo>.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/get-can-extract-frames-fast)
 */
const getCanExtractFramesFast = async ({ src, ffmpegExecutable, ffprobeExecutable, }) => {
    const remotionRoot = (0, find_closest_package_json_1.findRemotionRoot)();
    const out = await (0, ensure_presentation_timestamp_1.ensurePresentationTimestampWithoutCache)({
        ffmpegExecutable: ffmpegExecutable !== null && ffmpegExecutable !== void 0 ? ffmpegExecutable : null,
        ffprobeExecutable: ffprobeExecutable !== null && ffprobeExecutable !== void 0 ? ffprobeExecutable : null,
        remotionRoot,
        src,
    });
    const { specialVcodecForTransparency: specialVcodec } = await (0, get_video_info_1.getVideoInfoUncached)({
        src: out,
        ffprobeExecutable: ffprobeExecutable !== null && ffprobeExecutable !== void 0 ? ffprobeExecutable : null,
        remotionRoot,
    });
    if (specialVcodec === 'vp8') {
        fs_1.default.unlinkSync(out);
        return {
            canExtractFramesFast: false,
            shouldReencode: false,
        };
    }
    const { duration } = await (0, get_video_stream_duration_1.getVideoStreamDurationwithoutCache)({
        ffprobeExecutable: ffprobeExecutable !== null && ffprobeExecutable !== void 0 ? ffprobeExecutable : null,
        remotionRoot,
        src: out,
    });
    if (duration === null) {
        fs_1.default.unlinkSync(out);
        throw new Error(`Could not determine the duration of ${src} using FFMPEG. The file is not supported.`);
    }
    const actualOffset = `${duration * 1000 - exports.ACCEPTABLE_OFFSET_THRESHOLD}ms`;
    const [stdErr] = await (0, try_to_extract_frame_of_video_fast_1.tryToExtractFrameOfVideoFast)({
        actualOffset,
        ffmpegExecutable: ffmpegExecutable !== null && ffmpegExecutable !== void 0 ? ffmpegExecutable : null,
        imageFormat: 'jpeg',
        // Intentionally leaving needsResize as null, because we don't need to resize
        needsResize: null,
        remotionRoot,
        specialVCodecForTransparency: specialVcodec,
        src: out,
    });
    fs_1.default.unlinkSync(out);
    const isEmpty = stdErr.includes('Output file is empty');
    if (isEmpty) {
        return {
            canExtractFramesFast: false,
            shouldReencode: true,
        };
    }
    return {
        canExtractFramesFast: true,
        shouldReencode: false,
    };
};
exports.getCanExtractFramesFast = getCanExtractFramesFast;
