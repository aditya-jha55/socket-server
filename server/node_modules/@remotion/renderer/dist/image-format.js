"use strict";
// Keeping the default image format PNG if you don't pass a
// value to the renderer for backwards compatibility.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateNonNullImageFormat = exports.validateSelectedPixelFormatAndImageFormatCombination = exports.DEFAULT_IMAGE_FORMAT = exports.validImageFormats = void 0;
exports.validImageFormats = ['png', 'jpeg', 'none'];
// However, the CLI will override it and use JPEG if suitable.
exports.DEFAULT_IMAGE_FORMAT = 'png';
// By returning a value, we improve testability as we can specifically test certain branches
const validateSelectedPixelFormatAndImageFormatCombination = (pixelFormat, imageFormat) => {
    if (imageFormat === 'none') {
        return 'none';
    }
    if (typeof pixelFormat === 'undefined') {
        return 'valid';
    }
    if (!exports.validImageFormats.includes(imageFormat)) {
        throw new TypeError(`Value ${imageFormat} is not valid as an image format.`);
    }
    if (pixelFormat !== 'yuva420p' && pixelFormat !== 'yuva444p10le') {
        return 'valid';
    }
    if (imageFormat !== 'png') {
        throw new TypeError(`Pixel format was set to '${pixelFormat}' but the image format is not PNG. To render transparent videos, you need to set PNG as the image format.`);
    }
    return 'valid';
};
exports.validateSelectedPixelFormatAndImageFormatCombination = validateSelectedPixelFormatAndImageFormatCombination;
const validateNonNullImageFormat = (imageFormat) => {
    if (imageFormat !== 'jpeg' && imageFormat !== 'png') {
        throw new TypeError('Image format should be either "png" or "jpeg"');
    }
};
exports.validateNonNullImageFormat = validateNonNullImageFormat;
