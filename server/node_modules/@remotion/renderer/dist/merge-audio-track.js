"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeAudioTrack = void 0;
const execa_1 = __importDefault(require("execa"));
const path_1 = __importDefault(require("path"));
const chunk_1 = require("./chunk");
const create_ffmpeg_complex_filter_1 = require("./create-ffmpeg-complex-filter");
const create_ffmpeg_merge_filter_1 = require("./create-ffmpeg-merge-filter");
const create_silent_audio_1 = require("./create-silent-audio");
const delete_directory_1 = require("./delete-directory");
const ffmpeg_flags_1 = require("./ffmpeg-flags");
const p_limit_1 = require("./p-limit");
const tmp_dir_1 = require("./tmp-dir");
const truthy_1 = require("./truthy");
const mergeAudioTrackUnlimited = async ({ ffmpegExecutable, outName, files, numberOfSeconds, downloadMap, remotionRoot, }) => {
    if (files.length === 0) {
        await (0, create_silent_audio_1.createSilentAudio)({
            outName,
            ffmpegExecutable,
            numberOfSeconds,
            remotionRoot,
        });
        return;
    }
    // Previously a bug: We cannot optimize for files.length === 1 because we need to pad the audio
    // In FFMPEG, the total number of left and right tracks that can be merged at one time is limited to 64
    if (files.length >= 32) {
        const chunked = (0, chunk_1.chunk)(files, 10);
        const tempPath = (0, tmp_dir_1.tmpDir)('remotion-large-audio-mixing');
        try {
            const chunkNames = await Promise.all(chunked.map(async (chunkFiles, i) => {
                const chunkOutname = path_1.default.join(tempPath, `chunk-${i}.wav`);
                await (0, exports.mergeAudioTrack)({
                    ffmpegExecutable,
                    files: chunkFiles,
                    numberOfSeconds,
                    outName: chunkOutname,
                    downloadMap,
                    remotionRoot,
                });
                return chunkOutname;
            }));
            await (0, exports.mergeAudioTrack)({
                ffmpegExecutable,
                files: chunkNames.map((c) => ({
                    filter: {
                        pad_end: null,
                        pad_start: null,
                    },
                    outName: c,
                })),
                numberOfSeconds,
                outName,
                downloadMap,
                remotionRoot,
            });
            return;
        }
        finally {
            (0, delete_directory_1.deleteDirectory)(tempPath);
        }
    }
    const { complexFilterFlag: mergeFilter, cleanup } = await (0, create_ffmpeg_complex_filter_1.createFfmpegComplexFilter)({
        filters: files,
        downloadMap,
        ffmpegExecutable,
        remotionRoot,
    });
    const args = [
        ...files.map((f) => ['-i', f.outName]),
        mergeFilter,
        ['-c:a', 'pcm_s16le'],
        ['-map', `[${create_ffmpeg_merge_filter_1.OUTPUT_FILTER_NAME}]`],
        ['-y', outName],
    ]
        .filter(truthy_1.truthy)
        .flat(2);
    const task = (0, execa_1.default)(await (0, ffmpeg_flags_1.getExecutableBinary)(ffmpegExecutable, remotionRoot, 'ffmpeg'), args);
    await task;
    cleanup();
};
// Must be at least 3 because recursively called twice in mergeAudioTrack
const limit = (0, p_limit_1.pLimit)(3);
const mergeAudioTrack = (options) => {
    return limit(mergeAudioTrackUnlimited, options);
};
exports.mergeAudioTrack = mergeAudioTrack;
