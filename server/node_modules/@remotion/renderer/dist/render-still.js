"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderStill = void 0;
const fs_1 = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const remotion_1 = require("remotion");
const download_map_1 = require("./assets/download-map");
const browser_1 = require("./browser");
const convert_to_positive_frame_index_1 = require("./convert-to-positive-frame-index");
const ensure_output_directory_1 = require("./ensure-output-directory");
const handle_javascript_exception_1 = require("./error-handling/handle-javascript-exception");
const find_closest_package_json_1 = require("./find-closest-package-json");
const image_format_1 = require("./image-format");
const legacy_webpack_config_1 = require("./legacy-webpack-config");
const make_cancel_signal_1 = require("./make-cancel-signal");
const open_browser_1 = require("./open-browser");
const prepare_server_1 = require("./prepare-server");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const quality_1 = require("./quality");
const seek_to_frame_1 = require("./seek-to-frame");
const set_props_and_env_1 = require("./set-props-and-env");
const take_frame_and_compose_1 = require("./take-frame-and-compose");
const validate_puppeteer_timeout_1 = require("./validate-puppeteer-timeout");
const validate_scale_1 = require("./validate-scale");
const innerRenderStill = async ({ composition, quality, imageFormat = 'png', serveUrl, puppeteerInstance, dumpBrowserLogs = false, onError, inputProps, envVariables, output, frame = 0, overwrite = true, browserExecutable, timeoutInMilliseconds, chromiumOptions, scale = 1, proxyPort, cancelSignal, downloadMap, }) => {
    remotion_1.Internals.validateDimension(composition.height, 'height', 'in the `config` object passed to `renderStill()`');
    remotion_1.Internals.validateDimension(composition.width, 'width', 'in the `config` object passed to `renderStill()`');
    remotion_1.Internals.validateFps(composition.fps, 'in the `config` object of `renderStill()`', false);
    remotion_1.Internals.validateDurationInFrames({
        durationInFrames: composition.durationInFrames,
        component: 'in the `config` object passed to `renderStill()`',
        allowFloats: false,
    });
    (0, image_format_1.validateNonNullImageFormat)(imageFormat);
    remotion_1.Internals.validateFrame({
        frame,
        durationInFrames: composition.durationInFrames,
        allowFloats: false,
    });
    const stillFrame = (0, convert_to_positive_frame_index_1.convertToPositiveFrameIndex)({
        durationInFrames: composition.durationInFrames,
        frame,
    });
    (0, validate_puppeteer_timeout_1.validatePuppeteerTimeout)(timeoutInMilliseconds);
    (0, validate_scale_1.validateScale)(scale);
    output =
        typeof output === 'string' ? path_1.default.resolve(process.cwd(), output) : null;
    if (quality !== undefined && imageFormat !== 'jpeg') {
        throw new Error("You can only pass the `quality` option if `imageFormat` is 'jpeg'.");
    }
    (0, quality_1.validateQuality)(quality);
    if (output) {
        if (fs_1.default.existsSync(output)) {
            if (!overwrite) {
                throw new Error(`Cannot render still - "overwrite" option was set to false, but the output destination ${output} already exists.`);
            }
            const stat = (0, fs_1.statSync)(output);
            if (!stat.isFile()) {
                throw new Error(`The output location ${output} already exists, but is not a file, but something else (e.g. folder). Cannot save to it.`);
            }
        }
        (0, ensure_output_directory_1.ensureOutputDirectory)(output);
    }
    const browserInstance = puppeteerInstance !== null && puppeteerInstance !== void 0 ? puppeteerInstance : (await (0, open_browser_1.openBrowser)(browser_1.DEFAULT_BROWSER, {
        browserExecutable,
        shouldDumpIo: dumpBrowserLogs,
        chromiumOptions,
        forceDeviceScaleFactor: scale !== null && scale !== void 0 ? scale : 1,
    }));
    const page = await browserInstance.newPage();
    await page.setViewport({
        width: composition.width,
        height: composition.height,
        deviceScaleFactor: scale !== null && scale !== void 0 ? scale : 1,
    });
    const errorCallback = (err) => {
        onError(err);
        cleanup();
    };
    const cleanUpJSException = (0, handle_javascript_exception_1.handleJavascriptException)({
        page,
        onError: errorCallback,
        frame: null,
    });
    const cleanup = async () => {
        cleanUpJSException();
        if (puppeteerInstance) {
            await page.close();
        }
        else {
            browserInstance.close(true).catch((err) => {
                console.log('Unable to close browser', err);
            });
        }
    };
    cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
        cleanup();
    });
    await (0, set_props_and_env_1.setPropsAndEnv)({
        inputProps,
        envVariables,
        page,
        serveUrl,
        initialFrame: stillFrame,
        timeoutInMilliseconds,
        proxyPort,
        retriesRemaining: 2,
        audioEnabled: false,
        videoEnabled: true,
    });
    await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        // eslint-disable-next-line max-params
        pageFunction: (id, defaultProps, durationInFrames, fps, height, width) => {
            window.setBundleMode({
                type: 'composition',
                compositionName: id,
                compositionDefaultProps: defaultProps,
                compositionDurationInFrames: durationInFrames,
                compositionFps: fps,
                compositionHeight: height,
                compositionWidth: width,
            });
        },
        args: [
            composition.id,
            composition.defaultProps,
            composition.durationInFrames,
            composition.fps,
            composition.height,
            composition.width,
        ],
        frame: null,
        page,
    });
    await (0, seek_to_frame_1.seekToFrame)({ frame: stillFrame, page });
    const { buffer } = await (0, take_frame_and_compose_1.takeFrameAndCompose)({
        downloadMap,
        frame: stillFrame,
        freePage: page,
        height: composition.height,
        width: composition.width,
        imageFormat,
        scale,
        output,
        quality,
        wantsBuffer: !output,
    });
    await cleanup();
    return { buffer: output ? null : buffer };
};
/**
 *
 * @description Render a still frame from a composition
 * @see [Documentation](https://www.remotion.dev/docs/renderer/render-still)
 */
const renderStill = (options) => {
    var _a, _b;
    const selectedServeUrl = (0, legacy_webpack_config_1.getServeUrlWithFallback)(options);
    const downloadMap = (_a = options.downloadMap) !== null && _a !== void 0 ? _a : (0, download_map_1.makeDownloadMap)();
    const onDownload = (_b = options.onDownload) !== null && _b !== void 0 ? _b : (() => () => undefined);
    const happyPath = new Promise((resolve, reject) => {
        var _a, _b, _c;
        const onError = (err) => reject(err);
        let close = null;
        (0, prepare_server_1.prepareServer)({
            webpackConfigOrServeUrl: selectedServeUrl,
            onDownload,
            onError,
            ffmpegExecutable: (_a = options.ffmpegExecutable) !== null && _a !== void 0 ? _a : null,
            ffprobeExecutable: (_b = options.ffprobeExecutable) !== null && _b !== void 0 ? _b : null,
            port: (_c = options.port) !== null && _c !== void 0 ? _c : null,
            downloadMap,
            remotionRoot: (0, find_closest_package_json_1.findRemotionRoot)(),
        })
            .then(({ serveUrl, closeServer, offthreadPort }) => {
            close = closeServer;
            return innerRenderStill({
                ...options,
                serveUrl,
                onError: (err) => reject(err),
                proxyPort: offthreadPort,
                downloadMap,
            });
        })
            .then((res) => resolve(res))
            .catch((err) => reject(err))
            .finally(() => {
            // Clean download map if it was not passed in
            if (!(options === null || options === void 0 ? void 0 : options.downloadMap)) {
                (0, download_map_1.cleanDownloadMap)(downloadMap);
            }
            return close === null || close === void 0 ? void 0 : close(false);
        });
    });
    return Promise.race([
        happyPath,
        new Promise((_resolve, reject) => {
            var _a;
            (_a = options.cancelSignal) === null || _a === void 0 ? void 0 : _a.call(options, () => {
                reject(new Error(make_cancel_signal_1.cancelErrorMessages.renderStill));
            });
        }),
    ]);
};
exports.renderStill = renderStill;
