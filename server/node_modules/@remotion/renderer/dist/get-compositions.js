"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCompositions = void 0;
const download_map_1 = require("./assets/download-map");
const handle_javascript_exception_1 = require("./error-handling/handle-javascript-exception");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_browser_instance_1 = require("./get-browser-instance");
const prepare_server_1 = require("./prepare-server");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const seek_to_frame_1 = require("./seek-to-frame");
const set_props_and_env_1 = require("./set-props-and-env");
const validate_ffmpeg_1 = require("./validate-ffmpeg");
const validate_puppeteer_timeout_1 = require("./validate-puppeteer-timeout");
const innerGetCompositions = async (serveUrl, page, config, proxyPort) => {
    if (config === null || config === void 0 ? void 0 : config.onBrowserLog) {
        page.on('console', (log) => {
            var _a;
            (_a = config.onBrowserLog) === null || _a === void 0 ? void 0 : _a.call(config, {
                stackTrace: log.stackTrace(),
                text: log.text,
                type: log.type,
            });
        });
    }
    (0, validate_puppeteer_timeout_1.validatePuppeteerTimeout)(config === null || config === void 0 ? void 0 : config.timeoutInMilliseconds);
    await (0, set_props_and_env_1.setPropsAndEnv)({
        inputProps: config === null || config === void 0 ? void 0 : config.inputProps,
        envVariables: config === null || config === void 0 ? void 0 : config.envVariables,
        page,
        serveUrl,
        initialFrame: 0,
        timeoutInMilliseconds: config === null || config === void 0 ? void 0 : config.timeoutInMilliseconds,
        proxyPort,
        retriesRemaining: 2,
        audioEnabled: false,
        videoEnabled: false,
    });
    await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        page,
        pageFunction: () => {
            window.setBundleMode({
                type: 'evaluation',
            });
        },
        frame: null,
        args: [],
    });
    await (0, seek_to_frame_1.waitForReady)(page);
    const result = await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        pageFunction: () => {
            return window.getStaticCompositions();
        },
        frame: null,
        page,
        args: [],
    });
    return result;
};
/**
 * @description Gets the compositions defined in a Remotion project based on a Webpack bundle.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/get-compositions)
 */
const getCompositions = async (serveUrlOrWebpackUrl, config) => {
    var _a, _b, _c, _d, _e;
    await (0, validate_ffmpeg_1.validateFfmpeg)((_a = config === null || config === void 0 ? void 0 : config.ffmpegExecutable) !== null && _a !== void 0 ? _a : null, (0, find_closest_package_json_1.findRemotionRoot)(), 'ffmpeg');
    await (0, validate_ffmpeg_1.validateFfmpeg)((_b = config === null || config === void 0 ? void 0 : config.ffprobeExecutable) !== null && _b !== void 0 ? _b : null, (0, find_closest_package_json_1.findRemotionRoot)(), 'ffprobe');
    const downloadMap = (_c = config === null || config === void 0 ? void 0 : config.downloadMap) !== null && _c !== void 0 ? _c : (0, download_map_1.makeDownloadMap)();
    const { page, cleanup } = await (0, get_browser_instance_1.getPageAndCleanupFn)({
        passedInInstance: config === null || config === void 0 ? void 0 : config.puppeteerInstance,
        browserExecutable: (_d = config === null || config === void 0 ? void 0 : config.browserExecutable) !== null && _d !== void 0 ? _d : null,
        chromiumOptions: (_e = config === null || config === void 0 ? void 0 : config.chromiumOptions) !== null && _e !== void 0 ? _e : {},
    });
    return new Promise((resolve, reject) => {
        var _a, _b, _c;
        const onError = (err) => reject(err);
        const cleanupPageError = (0, handle_javascript_exception_1.handleJavascriptException)({
            page,
            frame: null,
            onError,
        });
        let close = null;
        (0, prepare_server_1.prepareServer)({
            webpackConfigOrServeUrl: serveUrlOrWebpackUrl,
            onDownload: () => undefined,
            onError,
            ffmpegExecutable: (_a = config === null || config === void 0 ? void 0 : config.ffmpegExecutable) !== null && _a !== void 0 ? _a : null,
            ffprobeExecutable: (_b = config === null || config === void 0 ? void 0 : config.ffprobeExecutable) !== null && _b !== void 0 ? _b : null,
            port: (_c = config === null || config === void 0 ? void 0 : config.port) !== null && _c !== void 0 ? _c : null,
            downloadMap,
            remotionRoot: (0, find_closest_package_json_1.findRemotionRoot)(),
        })
            .then(({ serveUrl, closeServer, offthreadPort }) => {
            close = closeServer;
            return innerGetCompositions(serveUrl, page, config !== null && config !== void 0 ? config : {}, offthreadPort);
        })
            .then((comp) => {
            if (close) {
                return Promise.all([comp, close(true)]);
            }
            return Promise.resolve([comp, null]);
        })
            .then(([comp]) => {
            return resolve(comp);
        })
            .catch((err) => {
            reject(err);
        })
            .finally(() => {
            cleanup();
            cleanupPageError();
            // Clean download map if it was not passed in
            if (!(config === null || config === void 0 ? void 0 : config.downloadMap)) {
                (0, download_map_1.cleanDownloadMap)(downloadMap);
            }
        });
    });
};
exports.getCompositions = getCompositions;
