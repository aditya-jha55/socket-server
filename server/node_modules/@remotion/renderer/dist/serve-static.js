"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveStatic = void 0;
const http_1 = __importDefault(require("http"));
const get_port_1 = require("./get-port");
const offthread_video_server_1 = require("./offthread-video-server");
const serve_handler_1 = require("./serve-handler");
const serveStatic = async (path, options) => {
    const offthreadRequest = (0, offthread_video_server_1.startOffthreadVideoServer)({
        ffmpegExecutable: options.ffmpegExecutable,
        ffprobeExecutable: options.ffprobeExecutable,
        onDownload: options.onDownload,
        onError: options.onError,
        downloadMap: options.downloadMap,
        remotionRoot: options.remotionRoot,
    });
    const connections = {};
    const server = http_1.default.createServer((request, response) => {
        var _a;
        if ((_a = request.url) === null || _a === void 0 ? void 0 : _a.startsWith('/proxy')) {
            return offthreadRequest(request, response);
        }
        if (path === null) {
            response.writeHead(404);
            response.end('Server only supports /proxy');
            return;
        }
        (0, serve_handler_1.serveHandler)(request, response, {
            public: path,
        }).catch(() => {
            response.statusCode = 500;
            response.end('Error serving file');
        });
    });
    server.on('connection', (conn) => {
        const key = conn.remoteAddress + ':' + conn.remotePort;
        connections[key] = conn;
        conn.on('close', () => {
            delete connections[key];
        });
    });
    let selectedPort = null;
    const maxTries = 5;
    for (let i = 0; i < maxTries; i++) {
        try {
            selectedPort = await new Promise((resolve, reject) => {
                var _a;
                (0, get_port_1.getDesiredPort)((_a = options === null || options === void 0 ? void 0 : options.port) !== null && _a !== void 0 ? _a : undefined, 3000, 3100)
                    .then(({ port, didUsePort }) => {
                    server.listen(port);
                    server.on('listening', () => {
                        resolve(port);
                        return didUsePort();
                    });
                    server.on('error', (err) => {
                        reject(err);
                    });
                })
                    .catch((err) => reject(err));
            });
            const destroyConnections = function () {
                for (const key in connections)
                    connections[key].destroy();
            };
            const close = () => {
                return new Promise((resolve, reject) => {
                    destroyConnections();
                    server.close((err) => {
                        if (err) {
                            if (err.code ===
                                'ERR_SERVER_NOT_RUNNING') {
                                return resolve();
                            }
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                    });
                });
            };
            return { port: selectedPort, close };
        }
        catch (err) {
            if (!(err instanceof Error)) {
                throw err;
            }
            const codedError = err;
            if (codedError.code === 'EADDRINUSE') {
                // Already in use, try another port
            }
            else {
                throw err;
            }
        }
    }
    throw new Error(`Tried ${maxTries} times to find a free port. Giving up.`);
};
exports.serveStatic = serveStatic;
