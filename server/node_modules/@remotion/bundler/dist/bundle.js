"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundle = exports.getConfig = void 0;
const fs_1 = __importStar(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const webpack_1 = __importDefault(require("webpack"));
const worker_threads_1 = require("worker_threads");
const copy_dir_1 = require("./copy-dir");
const index_html_1 = require("./index-html");
const read_recursively_1 = require("./read-recursively");
const webpack_config_1 = require("./webpack-config");
const promisified = (0, util_1.promisify)(webpack_1.default);
const prepareOutDir = async (specified) => {
    if (specified) {
        await fs_1.default.promises.mkdir(specified, { recursive: true });
        return specified;
    }
    return fs_1.default.promises.mkdtemp(path_1.default.join(os_1.default.tmpdir(), 'remotion-webpack-bundle-'));
};
const trimLeadingSlash = (p) => {
    if (p.startsWith('/')) {
        return trimLeadingSlash(p.substr(1));
    }
    return p;
};
const trimTrailingSlash = (p) => {
    if (p.endsWith('/')) {
        return trimTrailingSlash(p.substr(0, p.length - 1));
    }
    return p;
};
const getConfig = ({ entryPoint, outDir, resolvedRemotionRoot, onProgress, options, }) => {
    var _a, _b;
    const entry = require.resolve('./renderEntry');
    return (0, webpack_config_1.webpackConfig)({
        entry,
        userDefinedComponent: entryPoint,
        outDir,
        environment: 'production',
        webpackOverride: (_a = options === null || options === void 0 ? void 0 : options.webpackOverride) !== null && _a !== void 0 ? _a : ((f) => f),
        onProgress,
        enableCaching: (_b = options === null || options === void 0 ? void 0 : options.enableCaching) !== null && _b !== void 0 ? _b : true,
        maxTimelineTracks: 15,
        // For production, the variables are set dynamically
        envVariables: {},
        entryPoints: [],
        remotionRoot: resolvedRemotionRoot,
        keyboardShortcutsEnabled: false,
        poll: null,
    });
};
exports.getConfig = getConfig;
const convertArgumentsIntoOptions = (args) => {
    var _a;
    if (args.length === 0) {
        throw new TypeError('bundle() was called without arguments');
    }
    const firstArg = args[0];
    if (typeof firstArg === 'string') {
        return {
            entryPoint: firstArg,
            onProgress: args[1],
            ...((_a = args[2]) !== null && _a !== void 0 ? _a : {}),
        };
    }
    if (typeof firstArg.entryPoint !== 'string') {
        throw new TypeError('bundle() was called without the `entryPoint` option');
    }
    return firstArg;
};
const recursionLimit = 5;
const findClosestPackageJsonFolder = (currentDir) => {
    let possiblePackageJson = '';
    for (let i = 0; i < recursionLimit; i++) {
        possiblePackageJson = path_1.default.join(currentDir, 'package.json');
        const exists = fs_1.default.existsSync(possiblePackageJson);
        if (exists) {
            return path_1.default.dirname(possiblePackageJson);
        }
        currentDir = path_1.default.dirname(currentDir);
    }
    return null;
};
const validateEntryPoint = async (entryPoint) => {
    const contents = await fs_1.promises.readFile(entryPoint, 'utf8');
    if (!contents.includes('registerRoot')) {
        throw new Error([
            `You passed ${entryPoint} as your entry point, but this file does not contain "registerRoot".`,
            'You should use the file that calls registerRoot() as the entry point.',
            'To ignore this error, pass "ignoreRegisterRootWarning" to bundle().',
            'This error cannot be ignored on the CLI.',
        ].join(' '));
    }
};
/**
 * @description The method bundles a Remotion project using Webpack and prepares it for rendering using renderMedia()
 * @see [Documentation](https://www.remotion.dev/docs/bundle)
 */
async function bundle(...args) {
    var _a, _b, _c, _d;
    const actualArgs = convertArgumentsIntoOptions(args);
    const entryPoint = path_1.default.resolve(process.cwd(), actualArgs.entryPoint);
    const resolvedRemotionRoot = (_b = (_a = actualArgs === null || actualArgs === void 0 ? void 0 : actualArgs.rootDir) !== null && _a !== void 0 ? _a : findClosestPackageJsonFolder(entryPoint)) !== null && _b !== void 0 ? _b : process.cwd();
    if (!actualArgs.ignoreRegisterRootWarning) {
        await validateEntryPoint(entryPoint);
    }
    const outDir = await prepareOutDir((_c = actualArgs === null || actualArgs === void 0 ? void 0 : actualArgs.outDir) !== null && _c !== void 0 ? _c : null);
    // The config might use an override which might use
    // `process.cwd()`. The context should always be the Remotion root.
    // This is not supported in worker threads (used for tests)
    const currentCwd = process.cwd();
    if (worker_threads_1.isMainThread) {
        process.chdir(resolvedRemotionRoot);
    }
    const { onProgress, ...options } = actualArgs;
    const [, config] = (0, exports.getConfig)({
        outDir,
        entryPoint,
        resolvedRemotionRoot,
        onProgress,
        options,
    });
    const output = await promisified([config]);
    if (worker_threads_1.isMainThread) {
        process.chdir(currentCwd);
    }
    if (!output) {
        throw new Error('Expected webpack output');
    }
    const { errors } = output.toJson();
    if (errors !== undefined && errors.length > 0) {
        throw new Error(errors[0].message + '\n' + errors[0].details);
    }
    const baseDir = (_d = actualArgs === null || actualArgs === void 0 ? void 0 : actualArgs.publicPath) !== null && _d !== void 0 ? _d : '/';
    const staticHash = '/' +
        [trimTrailingSlash(trimLeadingSlash(baseDir)), 'public']
            .filter(Boolean)
            .join('/');
    const from = (options === null || options === void 0 ? void 0 : options.publicDir)
        ? path_1.default.resolve(resolvedRemotionRoot, options.publicDir)
        : path_1.default.join(resolvedRemotionRoot, 'public');
    const to = path_1.default.join(outDir, 'public');
    let symlinkWarningShown = false;
    const showSymlinkWarning = (ent, src) => {
        if (symlinkWarningShown) {
            return;
        }
        const absolutePath = path_1.default.join(src, ent.name);
        if (options.onSymlinkDetected) {
            options.onSymlinkDetected(absolutePath);
            return;
        }
        symlinkWarningShown = true;
        console.warn(`\nFound a symbolic link in the public folder (${absolutePath}). The symlink will be forwarded into the bundle.`);
    };
    if (fs_1.default.existsSync(from)) {
        await (0, copy_dir_1.copyDir)({
            src: from,
            dest: to,
            onSymlinkDetected: showSymlinkWarning,
            onProgress: (prog) => { var _a; return (_a = options.onPublicDirCopyProgress) === null || _a === void 0 ? void 0 : _a.call(options, prog); },
        });
    }
    const html = (0, index_html_1.indexHtml)({
        staticHash,
        baseDir,
        editorName: null,
        inputProps: null,
        remotionRoot: resolvedRemotionRoot,
        previewServerCommand: null,
        numberOfAudioTags: 0,
        publicFiles: (0, read_recursively_1.readRecursively)({
            folder: '.',
            startPath: from,
            staticHash,
            limit: 1000,
        }),
        includeFavicon: false,
        title: 'Remotion Bundle',
    });
    fs_1.default.writeFileSync(path_1.default.join(outDir, 'index.html'), html);
    return outDir;
}
exports.bundle = bundle;
